%-----------------------------------------------------------------------------%
\chapter{\babTiga}
%-----------------------------------------------------------------------------%
Pada bab ini penulis akan menjelaskan bagaimana implementasi \textit{tabling} pada \textit{contextual abduction} dengan memanfaatkan fitur \textit{answer subsumption} yang dibuat menggunakan bahasa pemrograman \textbf{XSB Prolog}. Pada bagian-bagian selanjutnya, program implementasi ini disebut sebagai \textsc{Tabdual}

\section{Terminologi}

Pada bagian ini penulis menjelaskan arti dari simbol-simbol/istilah-istilah yang akan digunakan pada bagian-bagian berikutnya. 

\begin{itemize}
	\item Secara umum, variabel diawali dengan huruf kapital sedangkan term dan predikat diawali dengan huruf non-kapital.
	\item \textit{consult} berarti melakukan kompilasi program Prolog dan memuat hasil kompilasi program tersebut ke dalam \textit{database} XSB Prolog sehingga program tersebut menjadi \textit{knowledge base}.
	\item \textit{database} berarti kumpulan predikat-predikat yang disimpan pada \textit{environment} XSB Prolog dan dijadikan sebagai \textit{knowledge base}. Predikat-predikat yang ada pada \textit{database} dapat berasal dari program yang di-\textit{consult} (membentuk \textit{database} statis) ataupun ditambahkan selama eksekusi suatu program (membentuk \textit{database} dinamis). Selama eksekusi, predikat yang sudah ditambahkan ke dalam \textit{database} dinamis dapat dimanipulasi sesuai kebutuhan program.
	\item \textit{dual transformation by need} mengacu pada proses transformasi dual \textit{by need} yang sudah dijelaskan pada bagian ???.
\end{itemize}

\section{Spesifikasi \textsc{Tabdual}}

\subsection{Fase pada \textsc{Tabdual}}

Secara garis besar, \textsc{Tabdual} terbagi menjadi 2 fase:

\begin{enumerate}
	\item \textbf{Transformasi}. Pada fase ini, \textsc{Tabdual} akan melakukan transformasi program input \textit{P} menjadi program output \textit{P$'$} yang dapat mengaplikasikan \textit{contextual abduction}. Transformasi dilakukan sesuai dengan aturan-aturan transformasi yang sudah dijelaskan pada \hyperref[bab2]{\textcolor{blue}{bab 2}}.
	\item \textbf{Abduction}. \textit{Contextual abduction} dapat dilakukan setelah program input \textit{P} berhasil ditransformasikan menjadi program output \textit{P$'$}. Praktis, \textit{P$'$} harus di-\textit{consult} terlebih dahulu sebelum kita dapat memberikan \textit{query} dan melakukan \textit{contextual abduction}.
	
	Penjelasan lebih detil mengenai setiap fase akan penulis jabarkan pada bagian-bagian berikutnya.
\end{enumerate}

\subsection{Berkas Implementasi \textsc{Tabdual}}
Implementasi \textsc{Tabdual} dipecah ke dalam empat buah berkas yang berbeda agar dapat digunakan secara modular. Keeempat berkas tersebut yaitu:

\begin{itemize}
	\item \textit{tabdual.P}. Berkas ini berisi implementasi utama dari \textsc{Tabdual}, baik implementasi untuk fase transformasi maupun implementsai untuk fase \textit{abduction}. Berkas ini adalah berkas yang harus di-\textit{consult} untuk dapat menggunakan \textsc{Tabdual}. Berkas-berkas lain yang diperlukan selama menggunakan \textsc{Tabdual} akan di-\textit{consult} melalui berkas ini.
	\item \textit{system.P}. Berkas ini berisi predikat-predikat bantuan dan predikat-predikat yang didefinisikan secara khusus yang akan digunakan  oleh \textsc{Tabdual} ketika melakukan \textit{tabling}, \textit{contextual abduction}, dan \textit{answer subsumption}. 
	\item \textit{read\_clause.P} Berkas ini berisi predikat-predikat yang dikhususkan untuk membaca program input agar dapat diproses dan ditransformasikan menggunakan \textsc{Tabdual}.
	\item \textit{write\_clause.P}. Berkas ini berisi predikat-predikat yang dikhususkan untuk menulis transformasi dari program input yang dihasilkan menggunakan \textsc{Tabdual} ke program output.
\end{itemize}

\subsection{Program Input}
Program input yang ingin ditransformasikan menggunakan \textsc{Tabdual} harus memenuhi kriteria-kriteria berikut:

\begin{itemize}
	\item \textit{Rule} ditulis dalam bentuk \textit{H $\leftarrow B_1, \textellipsis,B_n.$}, dengan operator $\leftarrow$ ditulis sebagai "<-" (tanda lebih kecil dari dari lalu \textit{dash}).
	\item Fakta ditulis dalam bentuk \textit{H}. saja tanpa operator $\leftarrow$.
	\item \textit{Abducible} ditulis sebagai fakta menggunakan predikat \textit{abds$/$}1 dengan argumennya yaitu himpunan \textit{abducible} yang direpresentasikan sebagai sebuah \textit{list} beserta dengan \textit{arity}-nya.
	\item Predikat-predikat yang hanya berupa fakta dan \textit{rule-rule} yang tidak ingin ditransformasikan ditulis terpisah di paling atas program input di antara predikat \textit{beginProlog} dan \textit{endProlog}. 
	\item Setiap \textit{rule} dan fakta yang ditulis diakhiri dengan tanda titik ".".
\end{itemize}

\noindent Agar lebih jelas, berikut ini merupakan contoh program yang diterima sebagai program input untuk \textsc{Tabdual},
\\

\begin{lstlisting}[
caption=Contoh program input yang diterima \textsc{Tabdual},
style=prolog,
numbers=left
]
beginProlog.
q(1).
q(2).
endProlog.

abds([a/1,b/1]).

r(X) <- a(X).
s(X) <- b(X).

<- q(X), r(X), s(X).
\end{lstlisting}

\noindent dan berikut ini merupakan contoh yang tidak diterima.
\\

\begin{lstlisting}[language=Prolog,
caption=Contoh program input yang tidak diterima \textsc{Tabdual},
style=prolog,
numbers=left
].
abds(a/1,b/1).			% argumen tidak berupa list

r(X) <- a(X).
s(X) <- b(X)			% rule tidak diakhiri dengan "."

beginProlog.			% diletakkan di bawah
q(1).
q(2).
endProlog

:- q(X), r(X), s(X).	% rule tidak menggunakan <-
\end{lstlisting}

\section{Pra Transformasi}

Bagian ini menjelaskan bagian implementasi \textsc{Tabdual} yang berkaitan sebelum fase transformasi dilakukan.

\subsection{\textit{Directive}}

Pada Prolog, \textit{directive} merupakan anotasi dan predikat pada program Prolog yang akan dieksekusi langsung oleh \textit{compiler} ketika program tersebut di-\textit{consult}. Berbeda dengan predikat biasa pada program, \textit{directive} tidak akan disimpan sebagai \textit{knowledge base}, melainkan langsung dieksekusi. Pada \textsc{Tabdual}, \textit{directive-directive} yang ada dapat dikelompokkan menjadi beberapa kelompok.

\subsubsection{\textit{Import}}

Untuk mempermudah pengguna, XSB Prolog sudah menyediakan predikat-predikat \textit{built-in} yang dapat digunakan langsung. Predikat \textit{built-in} tersebut dikelompokkan ke dalam modul-modul yang berbeda sesuai dengan kategori penggunaannya. \textit{Directive} berikut ini akan meng-\textit{import} beberapa predikat \textit{built-in} yang diperlukan oleh \textsc{Tabdual}.
\\

\begin{lstlisting}[
caption=Deklarasi \textit{directive}: \textit{import} modul yg diperlukan,
style=prolog,
]
:- import append/3, member/2, length/2 from basics.
:- import concat_atom/2 from string.
:- import trie_create/2, trie_drop/1 from intern.
\end{lstlisting}

Predikat \textit{append$/$}3, \textit{member$/$}2, dan \textit{length$/$}2 yang sudah disediakan dalam modul \textit{basics} berturut-turut digunakan untuk menggabungkan dua buah \textit{list}, mengecek presensi suatu elemen pada sebuah \textit{list}, dan menentukan panjang sebuah \textit{list}. Predikat \textit{concat\_atom$/$}2 yang sudah disediakan dalam modul \textit{string} digunakan untuk melakukan konkatenasi atom-atom untuk membentuk suatu atom baru. Predikat \textit{trie\_create$/$}2 dan \textit{trie\_drop$/$}1 yang sudah disediakan dalam modul \textit{intern} masing-masing digunakan untuk membuat dan menghapus \textit{trie} yang digunakan oleh \textit{dual transformation by need}.

\subsubsection{Operator}

Pada Prolog, operator logika baru dapat didefinisikan menggunakan predikat \textit{built-in} \textit{op$/$}3. Predikat \textit{op$/$}3 memiliki tiga buah argumen. Argumen pertama menyatakan presedensi operator, argumen kedua menyatakan tipe operator, dan argumen ketiga menyatakan nama operator. Presedensi dari operator dinyatakan sebagai sebuah bilangan bulat antara 1 sampai 1200 (presedensi sebuah term adalah 1), semakin kecil nilainya semakin kuat presedensinya. Tipe operator menentukan apakah operator tersebut merupakan operator \textit{prefix}, \textit{infix}, atau \textit{suffix}, sekaligus menyatakan sifat assosiatif yang dimilikinya, apakah assosiatif kanan, assosiatif kiri, atau tidak assosiatif. Tipe operator yang dapat digunakan untuk operator \textit{prefix} yaitu \textit{fx} dan \textit{fy}. Tipe operator yang dapat digunakan untuk operator \textit{infix} yaitu \textit{yfx}, \textit{xfy}, dan \textit{xfx}. Tipe operator yang dapat digunakan untuk operator \textit{suffix} yaitu \textit{xf} dan \textit{yf}. Simbol \textit{f} pada tipe operator merepresentasikan posisi operator sedangkan simbol \textit{x} dan \textit{y} merepresentasikan argumen-argumennya. Simbol \textit{x} menyatakan bahwa argumen tersebut harus memiliki presedensi kurang dari presedensi operator \textit{f}, sedangkan simbol \textit{y} menyatakan bahwa argumen tersebut harus memiliki presedensi kurang dari atau sama dengan presedensi operator \textit{f}. Dengan kata lain, simbol \textit{y} menyatakan bahwa operator tersebut bersifat assosiatif, sedangkan simbol \textit{x} menyatakan bahwa operator tersebut bersifat tidak assosiatif. \textsc{Tabdual} mendeklarasikan dua buah operator baru yaitu \textit{not} dan $\leftarrow$ seperti di bawah ini.
\\

\begin{lstlisting}[
caption=Deklarasi \textit{directive}: definisi operator baru,
style=prolog
]
:- op(950, fy, not).
:- op(1110, fy, '<-').
:- op(1110, xfy, '<-').
\end{lstlisting}

Operator \textit{not} digunakan untuk menyatakan negasi dari sebuah predikat sehingga tipe operatornya adalah \textit{fy}. Operator $\leftarrow$ digunakan untuk menyatakan implikasi yang dibalik untuk digunakan ketika mendefinisikan sebuah \textit{rule-rule} pada program input. Operator $\leftarrow$ memiliki dua tipe operator untuk dua penggunaan yang berbeda. Tipe operator yang pertama yaitu \textit{fy} digunakan untuk membentuk \textit{integrity constraint}, sedangkan tipe operator yang kedua yaitu \textit{xfy} digunakan untuk membentuk \textit{rule}.

\subsubsection{Predikat Dinamis}

Predikat dinamis adalah predikat yang definisinya bisa berubah-ubah. Predikat dinamis berguna untuk memanipulasi \textit{database} yang digunakan selama menjalankan sebuah program. \textsc{Tabdual} mendeklarasikan empat buah predikat dinamis yang digunakan sebagai domain-domain dari \textit{database} selama fase transformasi dan fase \textit{contextual abduction}. \textit{Directive} berikut ini mendeklarasikan keempat predikat dinamis yang digunakan. 
\\

\begin{lstlisting}[
caption=Deklarasi \textit{directive}: definisi operator baru,
style=prolog
]
:- dynamic has_rules/1, rule/2, rule/3, abds/1.
\end{lstlisting}

Predikat \textit{has\_rules$/$}1 digunakan untuk menyimpan informasi mengenai predikat yang memiliki \textit{rule}, dengan kata lain, predikat-predikat yang menjadi \textit{head} pada program. Argumen dari \textit{has\_rules$/$}1 yaitu \textit{R} yang menyatakan \textit{head} yang ada pada program. \textit{Head-head} ini disimpan pada \textit{database} menggunakan predikat dinamis \textit{has\_rules$/$}1 secara \textit{distinct}. Predikat \textit{rule$/$}2 dan \textit{rule$/$}3 digunakan untuk menyimpan informasi mengenai \textit{rule-rule} yang ada pada program. Dua buah argumen pertama dari \textit{rule$/$}2 dan \textit{rule$/$}3 yaitu \textit{H} dan \textit{B}, berturut-turut menyatakan \textit{head} dan \textit{body} dari \textit{rule} tersebut. Argumen ketiga dari \textit{rule$/$}3 yaitu sebuah bilangan \textit{N} yang menyatakan \textit{$H \leftarrow B$} adalah definisi ke-\textit{N} untuk \textit{rule} mengenai \textit{H}.\label{rule2to3} Penjelasan mengapa diperlukan dua buah predikat dinamis untuk menyimpan \textit{rule-rule} pada program input akan dijelaskan pada \hyperref[subsec:add_indices]{\textcolor{blue}{bagian 3.4.7}}. Predikat \textit{abds$/$}1 digunakan untuk menyimpan informasi mengenai himpunan \textit{abducible} yang direpresentasikan sebagai sebuah \textit{list}. Predikat \textit{abds$/$}1 memiliki satu buah argumen yaitu \textit{list} \textit{abducible} itu sendiri.

\subsubsection{\textit{Directive} Lainnya}

Karena dibutuhkan untuk fase transformasi dan \textit{contextual abduction}, beberapa predikat berikut ini perlu dijadikan sebagai \textit{directive} agar dieksekusi langsung ketika men-\textit{consult} \textsc{Tabdual}.
\\

\begin{lstlisting}[
caption=Deklarasi \textit{directive}: lainnya,
style=prolog
]
:- consult_files, retractall(mode/1), assert(mode(normal)).
\end{lstlisting}

Predikat \textit{consult\_files$/$}0 digunakan untuk men-\textit{consult} berkas-berkas implementasi \textsc{Tabdual} lainnya yang terdapat pada berkas \textit{system.P}, \textit{read\_clause.P}, dan \textit{write\_clause.P}. Predikat \textit{retractall}(\textit{mode$/$}1) dan \textit{assert}(\textit{mode}(\textit{normal})) digunakan untuk me-inisialisasi ulang mode yang digunakan untuk transformasi. Penjelasan mengenai mode transformasi akan dijelaskan lebih jauh pada \hyperref[subsec:mode]{\textcolor{blue}{bagian 3.4.8}}.

\subsection{Predikat \textit{wrapper} \textit{transform$/$}1}

Fase transformasi yang dilakukan \textsc{Tabdual} di-\textit{wrap} ke dalam satu buah predikat yaitu \textit{transform$/$}1. Predikat \textit{transform$/$}1 memiliki sebuah argumen yang menyatakan nama program input yang ingin ditransformasikan. Berikut definisi dari predikat \textit{transform$/$}1
\\

\begin{lstlisting}[
caption=Definisi predikat \textit{transform$/$}1,
style=prolog
]
transform(Filename) :-
	see_input_file(Filename),
	tell_output_file(Filename),
	pre_transform,
	transform,
	seen,
	told.
\end{lstlisting}

Terdapat enam buah \textit{goal} yang harus dieksekusi pada predikat \textit{transform$/$}1. Predikat \textit{see\_input\_file$/$}1 menentukan input \textit{stream} untuk fase transformasi \textsc{Tabdual} yaitu program input yang ingin ditransformasikan. Predikat \textit{tell\_output\_file$/$}1 menentukan output \textit{stream} untuk fase transformasi \textsc{Tabdual} yaitu program output yang akan dihasilkan. Program input harus memiliki ekstensi \textit{.ab} dan program output yang dihasilkan akan memiliki nama yang sama dengan program input namun dengan ekstensi \textit{.P}. Predikat \textit{pre\_transform$/$}0 melakukan beberapa hal yang harus dilakukan sebelum memulai transformasi (akan dijelaskan pada \hyperref[subsec:pre_transform]{\textcolor{blue}{bagian 3.4.3}} dan predikat \textit{transform$/$}0 adalah predikat yang akan melakukan transformasi (akan dijelaskan pada bagian ???). Predikat \textit{seen$/$}0 dan \textit{told$/$}0 berturut-turut mengembalikan input \textit{stream} dan output \textit{stream} menjadi seperti semula yaitu \textit{prompt} Prolog.

\subsection{Predikat \textit{pre\_transform/}0}
\label{subsec:pre_transform}

Terdapat beberapa hal perlu dilakukan sebelum memulai fase transformasi. Hal-hal tersebut di-\textit{wrap} ke dalam predikat \textit{pre\_transform$/$}0 yang pada \textsc{Tabdual} didefinisikan seperti di bawah ini.
\\

\begin{lstlisting}[
caption=Definisi predikat \textit{pre\_transform$/$}0,
style=prolog
]
pre_transform :-
	clear,
	load_rules,
	add_indices.
\end{lstlisting}

Terdapat tiga buah \textit{goal} yang harus dieksekusi pada predikat \textit{pre\_transform$/$}0. Predikat \textit{clear$/$}0 mengosongkan \textit{database} dengan menghapus semua predikat dinamis yang sudah tersimpan. Predikat \textit{load\_rules$/$}0 membaca program input dan menyimpan program yang didapat ke dalam \textit{database} menggunakan predikat dinamis. Predikat \textit{add\_indices$/$}0 menambahkan indeks pada setiap \textit{rule} yang disimpan menggunakan predikat dinamis \textit{rule$/$}2. Penjelasan lebih lanjut mengenai ketiga predikat ini akan dijelaskan pada bagian-bagian berikutnya.

\subsection{Predikat \textit{clear/}0}

Predikat \textit{clear$/$}0 digunakan untuk mengosongkan \textit{database} dengan menghapus semua predikat dinamis yang sudah tersimpan, sekaligus menghapus dan membuat ulang \textit{trie} yang digunakan oleh \textit{dual transformation by need}. Pada \textsc{Tabdual} predikat \textit{clear$/$}0 didefinisikan sebagai berikut.
\\

\begin{lstlisting}[
caption=Definisi predikat \textit{clear$/$}0,
style=prolog
]
clear :-
	retractall(has_rules/1),
	retractall(rule/2),
	retractall(rule/3), 
	retractall(abds/1),
	trie_drop(dual),
	trie_create(dual).
clear :-
	trie_create(dual).
\end{lstlisting}

Empat \textit{goal} pertama pada definisi predikat \textit{clear$/$}0 menghapus seluruh predikat dinamis yang sudah disimpan menggunakan predikat \textit{built-in} \textit{retractall$/$}1. Pada \textit{goal} selanjutnya, predikat \textit{trie\_drop$/$}1 menghapus dan membuat ulang \textit{trie} dengan alias \textit{dual} yang akan digunakan oleh \textit{dual transformation by need}. Jika penghapusan gagal, maka \textit{trie\_create$/$}2 pada definisi \textit{clear$/$}0 akan dieksekusi untuk membuat \textit{trie} yang baru, juga dengan alias \textit{dual}, agar dapat digunakan oleh \textit{dual transformation by need}.

\subsection{Predikat \textit{load\_rules/}0}

Predikat \textit{load\_rules$/$}0 membaca program input \textit{rule} demi \textit{rule} dan menyimpan \textit{rule} yang dibaca ke dalam \textit{database} menggunakan predikat dinamis. Berikut ini definisi dari predikat \textit{load\_rules$/$}0 pada \textsc{Tabdual} yang didefinisikan secara rekursif.
\\

\begin{lstlisting}[
caption=Definisi predikat \textit{load\_rules$/$}0,
style=prolog,
numbers=left,
xleftmargin=3em
]
load_rules :-
	read(C),
	(
	C = end_of_file 
	-> 
	true
	;
	C = beginProlog
	->
	load_just_facts
	;
	load_rule(C), 
	load_rules
	).
\end{lstlisting}

\textit{Goal} pertama yang dieksekusi pada predikat \textit{load\_rules$/$}0  yaitu predikat \textit{built-in} \textit{read$/$}1 yang digunakan untuk membaca satu term pada input \textit{stream} yang diberikan. Argumen dari predikat \textit{read$/$}1 yaitu term yang berhasil dibaca. Selanjutnya, potongan kode dari baris 3 hingga 14 merupakan \textit{statement} kondisional yang terdiri dari tiga buah kondisi yang saling \textit{mutually exclusive}, atau dengan kata lain, dapat dibaca sebagai kondisional \textit{if\textendash else if\textendash else}. Kondisi pertama merupakan \textit{base case}, yaitu jika term yang dibaca adalah term \textit{built-in end\_of\_file$/$}0, maka program output selesai dibaca dan \textit{load\_rules$/$}0 sukses. Kondisi kedua yaitu jika term yang dibaca adalah term \textit{beginProlog$/$}0, maka predikat \textit{load\_just\_facts$/$}0 akan dieksekusi sebagai sebuah \textit{goal}. Penjelasan lebih lanjut mengenai predikat \textit{load\_just\_facts$/$}0 akan dijelaskan pada bagian selanjutnya. Kondisi ketiga merupakan \textit{recursive case}, yaitu jika kedua kondisi sebelumnya tidak terpenuhi, maka predikat \textit{load\_rule$/$}1 akan dieksekusi sebagai sebuah \textit{goal}. Predikat \textit{load\_rule$/$}1 menyimpan term yang dibaca menggunakan predikat-predikat dinamis yang sesuai dengan bentuk term tersebut, apakah merupakan \textit{abducible}, rule, atau fakta. Setelah eksekusi predikat \textit{load\_rule$/$}1, terjadi pemanggilan rekursif terhadap predikat \textit{load\_rules$/$}0 yang terus diulang hingga seluruh program input selesai dibaca.

\subsection{Predikat \textit{load\_just\_facts/}0}

Predikat \textit{load\_just\_facts/}0 membaca term-term pada program input yang ditulis di antara predikat \textit{beginProlog} dan \textit{endProlog} kemudian langsung melakukan transformasi terhadap term-term tersebut. Pada \textsc{Tabdual}, predikat \textit{load\_just\_facts$/$}0 didefinisikan secara rekursif seperti berikut.
\\

\begin{lstlisting}[
caption=Definisi predikat \textit{load\_just\_facts$/$}0,
style=prolog,
numbers=left,
xleftmargin=3em
]
load_just_facts :-
	read(C),
	(
	C = endProlog
	->
	transform_just_fact,
	load_rules
	;
	load_rule(C),
	load_just_facts
	).
\end{lstlisting}

Sama seperti predikat \textit{load\_rules$/$}0, \textit{goal} pertama yang dieksekusi pada predikat \textit{load\_just\_facts$/$}0  yaitu predikat \textit{built-in} \textit{read$/$}1 yang digunakan untuk membaca satu term pada input \textit{stream} yang diberikan. Selanjutnya, potongan kode dari baris 3 hingga 14 merupakan \textit{statement} kondisional yang terdiri dari dua buah kondisi yang saling \textit{mutually exclusive}, atau dengan kata lain, dapat dibaca sebagai kondisional \textit{if\textendash else}. Kondisi pertama merupakan \textit{base case}, yaitu ketika term yang dibaca adalah term \textit{endProlog$/$}0. Artinya, seluruh term yang terdapat di antara predikat \textit{beginProlog$/$}0 dan \textit{endProlog$/$}0 sudah dibaca dan disimpan ke dalam \textit{database} sehingga dapat digunakan oleh predikat \textit{transform\_just\_facts$/$}0 untuk ditransformasikan sesuai dengan aturan transformasi pada bagian ???. Penjelasan lebih lanjut mengenai predikat \textit{transform\_just\_facts$/$}0 akan dijelaskan pada bagian ???. Selanjutnya, kondisi kedua merupakan \textit{recursive case}. Sama seperti pada predikat \textit{load\_rules$/$}0, predikat \textit{load\_rule$/$}1 akan dieksekusi sebagai sebuah \textit{goal}. Setelah eksekusi predikat \textit{load\_rule$/$}1, terjadi pemanggilan rekursif terhadap predikat \textit{load\_just\_facts$/$}0 yang terus diulang hingga bertemu dengan term \textit{endProlog$/$}0.

\subsection{Predikat \textit{add\_indices/}0}
\label{subsec:add_indices}

Pada \hyperref[rule2to3]{\textcolor{blue}{bagian sebelumnya}} telah dijelaskan bahwa diperlukan dua buah predikat dinamis untuk menyimpan \textit{rule-rule} pada program input, yaitu predikat dinamis \textit{rule$/$}2 dan \textit{rule$/$}3. Predikat dinamis \textit{rule$/$}3 merupakan ekstensi dari predikat dinamis \textit{rule$/$}2 dengan penambahan satu buah argumen yang menyatakan urutan definisi mengenai \textit{rule} tersebut. Informasi mengenai urutan ini diperlukan untuk mengimplementasikan \textit{dual transformation by need}. Predikat \textit{add\_indices$/$}0 memanfaatkan \textit{rule$/$}2 yang sudah tersimpan pada \textit{database} untuk membentuk \textit{rule$/$}3 yang sesuai. Berikut ini definisi dari predikat \textit{add\_indices$/$}0 pada \textsc{Tabdual}.
\\

\begin{lstlisting}[
caption=Definisi predikat \textit{add\_indices$/$}0,
style=prolog
]
add_indices :-
	retract(has_rules(H)),
	find_rules(H, R),
	add_indices_to_rule(R),
	add_indices,
	assert(has_rules(H)).
\end{lstlisting}

Terdapat lima buah \textit{goal} yang harus dieksekusi pada predikat \textit{add\_indices$/$}0. Predikat \textit{retract}(\textit{has\_rules$/$}1) menghapus informasi mengenai adanya \textit{rule H} dari \textit{database}. Dengan memanfaatkan \textit{rule$/$}2 yang sudah disimpan di \textit{database}, predikat \textit{find\_rules$/$}2 mengoleksikan seluruh \textit{rule} mengenai \textit{H} ke dalam sebuah \textit{list R}. Predikat \textit{add\_indices\_to\_rule$/$}1 menggunakan \textit{R} untuk membentuk sekaligus menyimpan \textit{rule$/$}3 yang sesuai. Selanjutnya terjadi pemanggilan rekursif terhadap predikat \textit{add\_indices$/$}0. Pemanggilan rekursif ini akan terus dilakukan hingga tidak ada lagi \textit{has\_rules$/$}1 pada \textit{database}. Setelah pemanggilan rekursif selesai dilakukan, setiap \textit{has\_rules$/$}1 yang baru saja dihapus ditambahkan kembali ke dalam \textit{database} untuk dapat dipergunakan kembali.

\label{subsec:mode}
\subsection{Predikat \textit{switch\_mode/}1}

\textsc{Tabdual} memiliki dua mode transformasi yang dapat dipilih oleh pengguna, yaitu transformasi \textit{normal} dan transformasi \textit{subsumed}. Mode transformasi \textit{normal} akan menghasilkan program output yang akan menggunakan teknik \textit{tabling} standar yang disediakan oleh XSB Prolog, sedangkan mode transformasi \textit{subsumed} akan menghasilkan program output yang akan menggunakan teknik \textit{tabling} dengan memanfaaatkan fitur \textit{answer subsumption}. Mode ransformasi \textit{normal} dapat digunakan ketika pengguna ingin melakukan \textit{abduction} untuk menememukan seluruh penjelasan terkait observasi yang diberikan. Mode transformasi \textit{subsumed} dapat digunakan ketika pengguna hanya tertarik untuk menemukan penjelasan-penjelasan minimal terkait observasi yang diberikan. \textsc{Tabdual} menyediakan predikat \textit{switch\_mode$/$}1 yang dapat digunakan untuk beralih dari satu mode transformasi ke mode lainnya. Hanya ada dua nilai yang dapat digunakan sebagai argumen dari predikat \textit{switch\_mode$/$}1, yaitu \textit{normal} atau \textit{subsumed}. Secara \textit{default}, mode transformasi yang digunakan yaitu mode transformasi \textit{normal}.

\section{Transformasi}

\section{\textit{Abduction}}

\section{Predikat Sistem}

\subsection{Predikat \textit{produce\_context}/3}

\subsection{Predikat \textit{insert\_abducible}/3}

\subsection{Predikat \textit{dual}/4}

%-----------------------------------------------------------------------------%
\section{Implementasi \f{Cluster}}
%-----------------------------------------------------------------------------%

%-----------------------------------------------------------------------------%
\subsection{Instalasi \f{Frontend}}
%-----------------------------------------------------------------------------%
Tabel model lain, ditunjukkan pada tabel \ref{tab:infohasti}. 
\begin{table}
	\centering
	\caption{Informasi \f{cluster} X}
	\newcolumntype{g}{>{\columncolor{headertbl}}c}
	\label{tab:infohasti}
	\begin{tabular}{|g|c|}
	\hline Host Name & X\\
	\hline Cluster Name & X\\
	\hline Certificate Organization & UI\\
	\hline Certificate Locality & Depok\\
	\hline Certificate State & West Java\\
	\hline Certificate Country & ID\\
	\hline Contact & X\\
	\hline URL & http://grid.ui.ac.id\\
	\hline
	\end{tabular}
\end{table}

Ada pagebreak disini.
%supaya rapih
\pagebreak

Another type of table
\begin{table}
	\centering
	\caption{Perbandingan Partisi \f{default} dan manual}
	\newcolumntype{g}{>{\columncolor{headertbl}}c}
	\label{tab:partdisk}
	\begin{tabular}{|g|c|c|}
	\rowcolor{headertbl}
	\hline & Partisi default & Partisi manual yang dilakukan\\
	\hline / & 16 GB & 30 GB\\
	\hline /var & 4 GB & 18 GB\\
	\hline swap & 1 GB & 2 GB\\
	\hline /export & 55 GB & 26 GB\\
	\hline
	\end{tabular}
\end{table}

Program menghasilkan keluaran seperti pada kode \ref{lst:raidready}. 

\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Keluaran output},label={lst:raidready}]
[root@nas-0-0 ~]# cat /proc/mdstat 
Personalities : [raid1] 
md0 : active raid1 sda4[0] sdb2[1]
      1917672312 blocks super 1.2 [2/2] [UU]
      
unused devices: <none>
[root@nas-0-0 ~]# mdadm --detail /dev/md0 
/dev/md0:
        Version : 1.2
  Creation Time : Fri May  3 15:38:52 2013
     Raid Level : raid1
     Array Size : 1917672312 (1828.83 GiB 1963.70 GB)
  Used Dev Size : 1917672312 (1828.83 GiB 1963.70 GB)
   Raid Devices : 2
  Total Devices : 2
    Persistence : Superblock is persistent

    Update Time : Tue May 28 11:27:49 2013
          State : clean 
 Active Devices : 2
Working Devices : 2
 Failed Devices : 0
  Spare Devices : 0

           Name : nas-0-0.local:0  (local to host nas-0-0.local)
           UUID : 0754726d:3dfbd4b9:42b0f587:68631556
         Events : 28

    Number   Major   Minor   RaidDevice State
       0       8        4        0      active sync   /dev/sda4
       1       8       18        1      active sync   /dev/sdb2
\end{lstlisting}
\end{minipage}

%-----------------------------------------------------------------------------%
\subsection{Konfigurasi}\label{cha:confcluster}
%-----------------------------------------------------------------------------%
Contoh verbatim dalam itemize : 
\begin{itemize}
\item \bo{Bold ini}\\
dijalankan perintah berikut : 
\begin{Verbatim}[frame=single]
# javac Ganteng.java
# java Ganteng
\end{Verbatim}
\paragraph{}
Perilaku sistem 
\begin{Verbatim}[frame=single]
# hai
# enable
# cd /export/rocks/install/
# create distro
# sh sesuatu.sh
# reboot
\end{Verbatim}
\paragraph{}

\item \bo{Menambahkan \f{package} pada \f{compute node}}\\
Langkah yang dilakukan adalah sebagai berikut : 
	\begin{enumerate}
	\item Masuk ke dalam direktori \co{/procfs/}
	\item Membuat/Mengubah berkas \co{xx.xml}. Jika tidak terdapat berkas tersebut, dapat disalin dari \co{skeleton.xml}.
	\item Menambahkan \f{package} yang ingin dipasang pada \f{compute node} diantara \f{tag} \co{<package>} seperti berikut : \co{<package>[package yang akan dipasang]</package>}.
	\item Menjalankan perintah berikut termasuk perintah untuk melakukan instalasi ulang seluruh \f{compute node}: 
	\begin{Verbatim}[frame=single]
# cd /export/somedir
# create
# run host
	\end{Verbatim}
	\end{enumerate}
	\paragraph{}
\end{itemize}
%-----------------------------------------------------------------------------%
\subsubsection{semakin ke dalam}
%-----------------------------------------------------------------------------%
\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Keluaran mentah untuk detail \f{job}}, label={lst:outqstatf},style=L]
[ardhi@xx ~]$ qstat -f 138
Job Id: 138.xx
    Job_Name = cur-1000-1np
    Job_Owner = ardhi@xx
    resources_used.cput = 27:21:35
    resources_used.mem = 86060kb
    resources_used.vmem = 170440kb
    resources_used.walltime = 27:24:50
    job_state = R
    queue = default
    server = hastinapura.grid.ui.ac.id
    Checkpoint = u
    ctime = Fri May 31 10:27:37 2013
    Error_Path = xx:/home/ardhi/xx/curcumin-1000/cur-1000-1np.e138
    exec_host = compute-0-5/0
    exec_port = 15003
    Hold_Types = n
    Join_Path = n
    Keep_Files = n
    Mail_Points = e
    Mail_Users = ardhi.putra@ui.ac.id
    mtime = Fri May 31 10:27:47 2013
    Output_Path = xx:/home/ardhi/xx/curcumin-1000/cur-1000-1np.o138
    Priority = 0
    qtime = Fri May 31 10:27:37 2013
    Rerunable = True
    Resource_List.nodes = 1:ppn=1
    session_id = 5768
    etime = Fri May 31 10:27:37 2013
    submit_args = cur-1000-1np.pbs
    start_time = Fri May 31 10:27:47 2013
    submit_host = xx
    init_work_dir = /home/ardhi/xx/curcumin-1000   
\end{lstlisting}
\end{minipage}

%-----------------------------------------------------------------------------%
\section{Pengujian} %lebih ke gimana cara ujinya
%-----------------------------------------------------------------------------%

%-----------------------------------------------------------------------------%
\subsection{Kasus Uji}
%-----------------------------------------------------------------------------%
Berwarna!
\begin{lstlisting}[caption=Potongan skrip submisi \f{job} melalui torqace,label={lst:grotorqace},style=shell]
# Go To working directory
cd $PBS_O_WORKDIR

#openMPI prerequisite
. /opt/torque/etc/openmpi-setup.sh

mpirun -np 5 -machinefile $PBS_NODEFILE mdrun -v -s \ 
	curcum400ps.tpr -o md_prod_curcum400_5np.trr -c lox_pr.gro
...
\end{lstlisting}
%-----------------------------------------------------------------------------%
\subsection{Kasus Uji}
%-----------------------------------------------------------------------------%
Contoh skrip yang dimasukkan pada \f{form} yang disediakan dapat dilihat pada kode \ref{lst:makebzip}.
\begin{lstlisting}[caption={Potongan \co{Makefile} \f{project}}, label={lst:makebzip},style=shell]
# Make file for MPI
SHELL=/bin/sh

# Compiler to use
# You may need to change CC to something like CC=mpiCC
# openmpi : mpiCC
# mpich2  : /opt/mpich2/gnu/bin/mpicxx
CC=mpiCC
...
...
\end{lstlisting}