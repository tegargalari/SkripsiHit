%-----------------------------------------------------------------------------%
\chapter{\babTiga}
%-----------------------------------------------------------------------------%
Pada bab ini penulis akan menjelaskan bagaimana implementasi \textit{tabling} pada \textit{contextual abduction} dengan memanfaatkan fitur \textit{answer subsumption} yang dibuat menggunakan bahasa pemrograman \textbf{XSB Prolog}. Pada bagian-bagian selanjutnya, program implementasi ini disebut sebagai \textsc{Tabdual}

\section{Terminologi}

Pada bagian ini penulis menjelaskan arti dari simbol-simbol/istilah-istilah yang akan digunakan pada bagian-bagian berikutnya. 

\begin{itemize}
	\item Secara umum, variabel diawali dengan huruf kapital sedangkan term dan predikat diawali dengan huruf non-kapital.
	\item \textit{consult} berarti melakukan kompilasi program Prolog dan memuat hasil kompilasi program tersebut ke dalam \textit{database} XSB Prolog sehingga program tersebut menjadi \textit{knowledge base}.
	\item \textit{database} berarti kumpulan predikat-predikat yang disimpan pada \textit{environment} XSB Prolog dan dijadikan sebagai \textit{knowledge base} selama eksekusi. Predikat-predikat yang ada pada \textit{database} dapat berasal dari program yang di-\textit{consult} (membentuk \textit{database} statis) ataupun ditambahkan selama eksekusi suatu program (membentuk \textit{database} dinamis). Selama eksekusi, predikat yang sudah ditambahkan ke dalam \textit{database} dinamis dapat dimanipulasi sesuai kebutuhan program.
	\item \textit{dual transformation by need} mengacu pada proses transformasi dual \textit{by need} yang sudah dijelaskan pada bagian ???.
\end{itemize}

\section{Spesifikasi \textsc{Tabdual}}

\subsection{Fase pada \textsc{Tabdual}}

Secara garis besar, \textsc{Tabdual} terbagi menjadi 2 fase:

\begin{enumerate}
	\item \textbf{Transformasi}. Pada fase ini, \textsc{Tabdual} akan melakukan transformasi program input \textit{P} menjadi program output \textit{P$'$} yang dapat mengaplikasikan \textit{contextual abduction}. Transformasi dilakukan sesuai dengan aturan-aturan transformasi yang sudah dijelaskan pada \hyperref[bab2]{\textcolor{blue}{bab 2}}.
	\item \textbf{Abduction}. \textit{Contextual abduction} dapat dilakukan setelah program input \textit{P} berhasil ditransformasikan menjadi program output \textit{P$'$}. Praktis, \textit{P$'$} harus di-\textit{consult} terlebih dahulu sebelum kita dapat memberikan \textit{query} dan melakukan \textit{contextual abduction}.
	
	Penjelasan lebih detil mengenai setiap fase akan penulis jabarkan pada bagian-bagian berikutnya.
\end{enumerate}

\subsection{Berkas Implementasi \textsc{Tabdual}}
Agar dapat digunakan secara modular, implementasi \textsc{Tabdual} dipecah ke dalam empat buah berkas yang berbeda. Keeempat berkas tersebut yaitu:

\begin{itemize}
	\item \textit{tabdual.P}. Berkas ini berisi implementasi utama dari \textsc{Tabdual}, baik implementasi untuk fase transformasi maupun implementsai untuk fase \textit{abduction}. Berkas ini adalah berkas yang harus di-\textit{consult} untuk dapat menggunakan \textsc{Tabdual}. Berkas-berkas lain yang diperlukan selama menggunakan \textsc{Tabdual} akan di-\textit{consult} melalui berkas ini.
	\item \textit{system.P}. Berkas ini berisi predikat-predikat bantuan dan predikat-predikat yang didefinisikan secara khusus yang akan digunakan  oleh \textsc{Tabdual} ketika melakukan \textit{tabling}, \textit{contextual abduction}, dan \textit{answer subsumption}. 
	\item \textit{read\_clause.P} Berkas ini berisi predikat-predikat yang dikhususkan untuk membaca program input agar dapat diproses dan ditransformasikan menggunakan \textsc{Tabdual}.
	\item \textit{write\_clause.P}. Berkas ini berisi predikat-predikat yang dikhususkan untuk menulis transformasi dari program input yang dihasilkan menggunakan \textsc{Tabdual} ke program output.
\end{itemize}

\subsection{Program Input}
Program input yang ingin ditransformasikan menggunakan \textsc{Tabdual} harus memenuhi kriteria-kriteria berikut:

\begin{itemize}
	\item \textit{Rule} ditulis dalam bentuk \textit{H $\leftarrow B_1, \textellipsis,B_n.$}, dengan operator $\leftarrow$ ditulis sebagai "<-" (tanda lebih kecil dari dari lalu \textit{dash}).
	\item Fakta ditulis dalam bentuk \textit{H}. saja tanpa operator $\leftarrow$.
	\item \textit{Abducible} ditulis sebagai fakta menggunakan predikat \textit{abds$/$}1 dengan argumennya yaitu himpunan \textit{abducible} yang direpresentasikan sebagai sebuah \textit{list} beserta dengan \textit{arity}-nya.
	\item Predikat-predikat yang hanya berupa fakta dan \textit{rule-rule} yang tidak ingin ditransformasikan ditulis terpisah di paling atas program input di antara predikat \textit{beginProlog} dan \textit{endProlog}. 
	\item Setiap \textit{rule} dan fakta yang ditulis diakhiri dengan tanda titik ".".
\end{itemize}

\noindent Agar lebih jelas, berikut ini merupakan contoh program yang diterima sebagai program input untuk \textsc{Tabdual},
\\

\begin{lstlisting}[
caption=Contoh program input yang diterima \textsc{Tabdual},
style=prolog,
numbers=left
]
beginProlog.
q(1).
q(2).
endProlog.

abds([a/1,b/1]).

r(X) <- a(X).
s(X) <- b(X).

<- q(X), r(X), s(X).
\end{lstlisting}

\noindent dan berikut ini merupakan contoh yang tidak diterima.
\\

\begin{lstlisting}[language=Prolog,
caption=Contoh program input yang tidak diterima \textsc{Tabdual},
style=prolog,
numbers=left
].
abds(a/1,b/1).			% argumen tidak berupa list

r(X) <- a(X).
s(X) <- b(X)			% rule tidak diakhiri dengan "."

beginProlog.			% diletakkan di bawah
q(1).
q(2).
endProlog

:- q(X), r(X), s(X).	% rule tidak menggunakan <-
\end{lstlisting}

\section{Pra Transformasi}

Bagian ini menjelaskan bagian implementasi \textsc{Tabdual} yang berkaitan sebelum fase transformasi dilakukan.

\subsection{\textit{Directive}}

Pada Prolog, \textit{directive} merupakan anotasi dan predikat pada program Prolog yang akan dieksekusi langsung oleh \textit{compiler} ketika program tersebut di-\textit{consult}. Berbeda dengan predikat biasa pada program, \textit{directive} tidak akan disimpan sebagai ke \textit{database}, melainkan langsung dieksekusi. Pada \textsc{Tabdual}, \textit{directive-directive} yang ada dapat dikelompokkan menjadi beberapa kelompok.

\subsubsection{\textit{Import}}

Untuk mempermudah pengguna, XSB Prolog sudah menyediakan predikat-predikat \textit{built-in} yang dapat digunakan langsung. Predikat \textit{built-in} tersebut dikelompokkan ke dalam modul-modul yang berbeda sesuai dengan kategori penggunaannya. \textit{Directive} berikut ini akan meng-\textit{import} beberapa predikat \textit{built-in} yang diperlukan oleh \textsc{Tabdual}.
\\

\begin{lstlisting}[
caption=Deklarasi \textit{directive}: \textit{import} modul yg diperlukan,
style=prolog,
]
:- import append/3, member/2, length/2 from basics.
:- import concat_atom/2 from string.
:- import trie_create/2, trie_drop/1 from intern.
\end{lstlisting}

Predikat \textit{append$/$}3, \textit{member$/$}2, dan \textit{length$/$}2 yang sudah disediakan dalam modul \textit{basics} berturut-turut digunakan untuk menggabungkan dua buah \textit{list}, mengecek presensi suatu elemen pada sebuah \textit{list}, dan menentukan panjang sebuah \textit{list}. Predikat \textit{concat\_atom$/$}2 yang sudah disediakan dalam modul \textit{string} digunakan untuk melakukan konkatenasi atom-atom untuk membentuk suatu atom baru. Predikat \textit{trie\_create$/$}2 dan \textit{trie\_drop$/$}1 yang sudah disediakan dalam modul \textit{intern} masing-masing digunakan untuk membuat dan menghapus \textit{trie} yang digunakan oleh \textit{dual transformation by need}.

\subsubsection{Deklarasi Operator}

Pada Prolog, operator logika baru dapat didefinisikan menggunakan predikat \textit{built-in} \textit{op$/$}3. Predikat \textit{op$/$}3 memiliki tiga buah argumen. Argumen pertama menyatakan presedensi operator, argumen kedua menyatakan tipe operator, dan argumen ketiga menyatakan nama operator. Presedensi dari operator dinyatakan sebagai sebuah bilangan bulat antara 1 sampai 1200 (presedensi sebuah term adalah 1), semakin kecil nilainya semakin kuat presedensinya. Tipe operator menentukan apakah operator tersebut merupakan operator \textit{prefix}, \textit{infix}, atau \textit{suffix}, sekaligus menyatakan sifat assosiatif yang dimilikinya, apakah assosiatif kanan, assosiatif kiri, atau tidak assosiatif. Tipe operator yang dapat digunakan untuk operator \textit{prefix} yaitu \textit{fx} dan \textit{fy}. Tipe operator yang dapat digunakan untuk operator \textit{infix} yaitu \textit{yfx}, \textit{xfy}, dan \textit{xfx}. Tipe operator yang dapat digunakan untuk operator \textit{suffix} yaitu \textit{xf} dan \textit{yf}. Simbol \textit{f} pada tipe operator merepresentasikan posisi operator sedangkan simbol \textit{x} dan \textit{y} merepresentasikan argumen-argumennya. Simbol \textit{x} menyatakan bahwa argumen tersebut harus memiliki presedensi kurang dari presedensi operator \textit{f}, sedangkan simbol \textit{y} menyatakan bahwa argumen tersebut harus memiliki presedensi kurang dari atau sama dengan presedensi operator \textit{f}. Dengan kata lain, simbol \textit{y} menyatakan bahwa operator tersebut bersifat assosiatif, sedangkan simbol \textit{x} menyatakan bahwa operator tersebut bersifat tidak assosiatif. \textsc{Tabdual} mendeklarasikan dua buah operator baru yaitu \textit{not} dan $\leftarrow$ seperti di bawah ini.
\\

\begin{lstlisting}[
caption=Deklarasi \textit{directive}: definisi operator baru,
style=prolog
]
:- op(950, fy, not).
:- op(1110, fy, '<-').
:- op(1110, xfy, '<-').
\end{lstlisting}

Operator \textit{not} digunakan untuk menyatakan negasi dari sebuah predikat sehingga tipe operatornya adalah \textit{fy}. Operator $\leftarrow$ digunakan untuk menyatakan implikasi yang dibalik untuk digunakan ketika mendefinisikan sebuah \textit{rule-rule} pada program input. Operator $\leftarrow$ memiliki dua tipe operator untuk dua penggunaan yang berbeda. Tipe operator yang pertama yaitu \textit{fy} digunakan untuk membentuk \textit{integrity constraint}, sedangkan tipe operator yang kedua yaitu \textit{xfy} digunakan untuk membentuk \textit{rule}.

\subsubsection{Deklarasi Predikat Dinamis}

Predikat dinamis adalah predikat yang definisinya bisa berubah-ubah. Predikat dinamis digunakan untuk memanipulasi \textit{database} selama eksekusi. \textsc{Tabdual} mendeklarasikan empat buah predikat dinamis yang digunakan selama fase transformasi dan fase \textit{abduction}. \textit{Directive} berikut ini mendeklarasikan keempat predikat dinamis yang digunakan. 
\\

\begin{lstlisting}[
caption=Deklarasi \textit{directive}: definisi operator baru,
style=prolog
]
:- dynamic has_rules/1, rule/2, rule/3, abds/1.
\end{lstlisting}

Predikat \textit{has\_rules$/$}1 digunakan untuk menyimpan informasi mengenai predikat yang memiliki \textit{rule}, dengan kata lain, predikat-predikat yang menjadi \textit{head} pada program. Argumen dari \textit{has\_rules$/$}1 yaitu \textit{R} yang menyatakan \textit{head} yang ada pada program. \textit{Head-head} ini disimpan pada \textit{database} menggunakan predikat dinamis \textit{has\_rules$/$}1 secara \textit{distinct}. Predikat \textit{rule$/$}2 dan \textit{rule$/$}3 digunakan untuk menyimpan informasi mengenai \textit{rule-rule} yang ada pada program. Dua buah argumen pertama dari \textit{rule$/$}2 dan \textit{rule$/$}3 yaitu \textit{H} dan \textit{B}, berturut-turut menyatakan \textit{head} dan \textit{body} dari \textit{rule} tersebut. Argumen ketiga dari \textit{rule$/$}3 yaitu sebuah bilangan \textit{N} yang menyatakan \textit{$H \leftarrow B$} adalah definisi ke-\textit{N} untuk \textit{rule} mengenai \textit{H}.\label{rule2to3} Penjelasan mengapa diperlukan dua buah predikat dinamis untuk menyimpan \textit{rule-rule} pada program input akan dijelaskan pada \hyperref[subsec:add_indices]{\textcolor{blue}{bagian 3.4.7}}. Predikat \textit{abds$/$}1 digunakan untuk menyimpan informasi mengenai himpunan \textit{abducible} yang direpresentasikan sebagai sebuah \textit{list}. Predikat \textit{abds$/$}1 memiliki satu buah argumen yaitu \textit{list} \textit{abducible} itu sendiri.

\subsubsection{\textit{Directive} Lainnya}

Karena dibutuhkan untuk fase transformasi dan \textit{contextual abduction}, beberapa predikat berikut ini perlu dijadikan sebagai \textit{directive} agar dieksekusi langsung ketika men-\textit{consult} \textsc{Tabdual}.
\\

\begin{lstlisting}[
caption=Deklarasi \textit{directive}: lainnya,
style=prolog
]
:- consult_files, retractall(mode/1), assert(mode(normal)).
\end{lstlisting}

Predikat \textit{consult\_files$/$}0 digunakan untuk men-\textit{consult} berkas-berkas implementasi \textsc{Tabdual} lainnya yang terdapat pada berkas \textit{system.P}, \textit{read\_clause.P}, dan \textit{write\_clause.P}. Predikat \textit{retractall}(\textit{mode$/$}1) dan \textit{assert}(\textit{mode}(\textit{normal})) digunakan untuk me-inisialisasi ulang mode yang digunakan untuk transformasi. Penjelasan mengenai mode transformasi akan dijelaskan lebih jauh pada \hyperref[subsec:mode]{\textcolor{blue}{bagian 3.4.8}}.

\subsection{Predikat \textit{wrapper} \textit{transform$/$}1}

Fase transformasi yang dilakukan \textsc{Tabdual} di-\textit{wrap} ke dalam satu buah predikat yaitu \textit{transform$/$}1. Predikat \textit{transform$/$}1 memiliki sebuah argumen yang menyatakan nama program input yang ingin ditransformasikan. Berikut definisi dari predikat \textit{transform$/$}1
\\

\begin{lstlisting}[
caption=Definisi predikat \textit{transform$/$}1,
style=prolog
]
transform(Filename) :-
	see_input_file(Filename),
	tell_output_file(Filename),
	pre_transform,
	transform,
	seen,
	told.
\end{lstlisting}

Terdapat enam buah \textit{goal} yang harus dieksekusi pada predikat \textit{transform$/$}1. Predikat \textit{see\_input\_file$/$}1 menentukan input \textit{stream} untuk fase transformasi \textsc{Tabdual} yaitu program input yang ingin ditransformasikan. Predikat \textit{tell\_output\_file$/$}1 menentukan output \textit{stream} untuk fase transformasi \textsc{Tabdual} yaitu program output yang akan dihasilkan. Program input harus memiliki ekstensi \textit{.ab} dan program output yang dihasilkan akan memiliki nama yang sama dengan program input namun dengan ekstensi \textit{.P}. Predikat \textit{pre\_transform$/$}0 melakukan beberapa hal yang harus dilakukan sebelum memulai transformasi (akan dijelaskan pada \hyperref[subsec:pre_transform]{\textcolor{blue}{bagian 3.4.3}} dan predikat \textit{transform$/$}0 adalah predikat yang akan melakukan transformasi (akan dijelaskan pada \hyperref[transform]{\textcolor{blue}{bagian 3.4}}). Predikat \textit{seen$/$}0 dan \textit{told$/$}0 berturut-turut mengembalikan input \textit{stream} dan output \textit{stream} menjadi seperti semula yaitu \textit{prompt} Prolog.

\subsection{Predikat \textit{pre\_transform/}0}
\label{subsec:pre_transform}

Terdapat beberapa hal perlu dilakukan sebelum memulai fase transformasi. Hal-hal tersebut di-\textit{wrap} ke dalam predikat \textit{pre\_transform$/$}0 yang pada \textsc{Tabdual} didefinisikan seperti di bawah ini.
\\

\begin{lstlisting}[
caption=Definisi predikat \textit{pre\_transform$/$}0,
style=prolog
]
pre_transform :-
	clear,
	load_rules,
	add_indices.
\end{lstlisting}

Terdapat tiga buah \textit{goal} yang harus dieksekusi pada predikat \textit{pre\_transform$/$}0. Predikat \textit{clear$/$}0 mengosongkan \textit{database} dengan menghapus semua predikat dinamis yang sudah tersimpan. Predikat \textit{load\_rules$/$}0 membaca program input dan menyimpan program yang didapat ke dalam \textit{database} menggunakan predikat dinamis. Predikat \textit{add\_indices$/$}0 menambahkan indeks pada setiap \textit{rule} yang disimpan menggunakan predikat dinamis \textit{rule$/$}2. Penjelasan lebih lanjut mengenai ketiga predikat ini akan dijelaskan pada bagian-bagian berikutnya.

\subsection{Predikat \textit{clear/}0}

Predikat \textit{clear$/$}0 digunakan untuk mengosongkan \textit{database} dengan menghapus semua predikat dinamis yang sudah tersimpan, sekaligus menghapus dan membuat ulang \textit{trie} yang digunakan oleh \textit{dual transformation by need}. Pada \textsc{Tabdual} predikat \textit{clear$/$}0 didefinisikan sebagai berikut.
\\

\begin{lstlisting}[
caption=Definisi predikat \textit{clear$/$}0,
style=prolog
]
clear :-
	retractall(has_rules/1),
	retractall(rule/2),
	retractall(rule/3), 
	retractall(abds/1),
	trie_drop(dual),
	trie_create(dual).
clear :-
	trie_create(dual).
\end{lstlisting}

Empat \textit{goal} pertama pada definisi predikat \textit{clear$/$}0 menghapus seluruh predikat dinamis yang sudah disimpan menggunakan predikat \textit{built-in} \textit{retractall$/$}1. Pada \textit{goal} selanjutnya, predikat \textit{trie\_drop$/$}1 menghapus dan membuat ulang \textit{trie} dengan alias \textit{dual} yang akan digunakan oleh \textit{dual transformation by need}. Jika penghapusan gagal, maka \textit{trie\_create$/$}2 pada definisi \textit{clear$/$}0 akan dieksekusi untuk membuat \textit{trie} yang baru, juga dengan alias \textit{dual}, agar dapat digunakan oleh \textit{dual transformation by need}.

\subsection{Predikat \textit{load\_rules/}0}

Predikat \textit{load\_rules$/$}0 membaca program input \textit{rule} demi \textit{rule} dan menyimpan \textit{rule} yang dibaca ke dalam \textit{database} menggunakan predikat dinamis. Berikut ini definisi dari predikat \textit{load\_rules$/$}0 pada \textsc{Tabdual} yang didefinisikan secara rekursif.
\\

\begin{lstlisting}[
caption=Definisi predikat \textit{load\_rules$/$}0,
style=prolog,
numbers=left,
xleftmargin=3em
]
load_rules :-
	read(C),
	(
	C = end_of_file 
	-> 
	true
	;
	C = beginProlog
	->
	load_just_facts
	;
	load_rule(C), 
	load_rules
	).
\end{lstlisting}

\textit{Goal} pertama yang dieksekusi pada predikat \textit{load\_rules$/$}0  yaitu predikat \textit{built-in} \textit{read$/$}1 yang digunakan untuk membaca satu term pada input \textit{stream} yang diberikan. Argumen dari predikat \textit{read$/$}1 yaitu term yang berhasil dibaca. Selanjutnya, potongan kode dari baris 3 hingga 14 merupakan \textit{statement} kondisional yang terdiri dari tiga buah kondisi yang saling \textit{mutually exclusive}, atau dengan kata lain, dapat dibaca sebagai kondisional \textit{if\textendash else if\textendash else}. Kondisi pertama merupakan \textit{base case}, yaitu jika term yang dibaca adalah term \textit{built-in end\_of\_file$/$}0, maka program output selesai dibaca dan \textit{load\_rules$/$}0 sukses. Kondisi kedua yaitu jika term yang dibaca adalah term \textit{beginProlog$/$}0, maka predikat \textit{load\_just\_facts$/$}0 akan dieksekusi sebagai sebuah \textit{goal}. Penjelasan lebih lanjut mengenai predikat \textit{load\_just\_facts$/$}0 akan dijelaskan pada bagian selanjutnya. Kondisi ketiga merupakan \textit{recursive case}, yaitu jika kedua kondisi sebelumnya tidak terpenuhi, maka predikat \textit{load\_rule$/$}1 akan dieksekusi sebagai sebuah \textit{goal}. Predikat \textit{load\_rule$/$}1 menyimpan term yang dibaca menggunakan predikat-predikat dinamis yang sesuai dengan bentuk term tersebut, apakah merupakan \textit{abducible}, rule, atau fakta. Setelah eksekusi predikat \textit{load\_rule$/$}1, terjadi pemanggilan rekursif terhadap predikat \textit{load\_rules$/$}0 yang terus diulang hingga seluruh program input selesai dibaca.

\subsection{Predikat \textit{load\_just\_facts/}0}

Predikat \textit{load\_just\_facts/}0 membaca term-term pada program input yang ditulis di antara predikat \textit{beginProlog} dan \textit{endProlog} kemudian langsung melakukan transformasi terhadap term-term tersebut. Pada \textsc{Tabdual}, predikat \textit{load\_just\_facts$/$}0 didefinisikan secara rekursif seperti berikut.
\\

\begin{lstlisting}[
caption=Definisi predikat \textit{load\_just\_facts$/$}0,
style=prolog,
numbers=left,
xleftmargin=3em
]
load_just_facts :-
	read(C),
	(
	C = endProlog
	->
	transform_just_fact,
	load_rules
	;
	load_rule(C),
	load_just_facts
	).
\end{lstlisting}

Sama seperti predikat \textit{load\_rules$/$}0, \textit{goal} pertama yang dieksekusi pada predikat \textit{load\_just\_facts$/$}0  yaitu predikat \textit{built-in} \textit{read$/$}1 yang digunakan untuk membaca satu term pada input \textit{stream} yang diberikan. Selanjutnya, potongan kode dari baris 3 hingga 14 merupakan \textit{statement} kondisional yang terdiri dari dua buah kondisi yang saling \textit{mutually exclusive}, atau dengan kata lain, dapat dibaca sebagai kondisional \textit{if\textendash else}. Kondisi pertama merupakan \textit{base case}, yaitu ketika term yang dibaca adalah term \textit{endProlog$/$}0. Artinya, seluruh term yang terdapat di antara predikat \textit{beginProlog$/$}0 dan \textit{endProlog$/$}0 sudah dibaca dan disimpan ke dalam \textit{database} sehingga dapat digunakan oleh predikat \textit{transform\_just\_facts$/$}0 \label{justfacts2} untuk ditransformasikan sesuai dengan aturan transformasi pada bagian ???. Penjelasan lebih lanjut mengenai predikat \textit{transform\_just\_facts$/$}0 akan dijelaskan pada \hyperref[justfacts]{\textcolor{blue}{bagian 3.4.4}}. Selanjutnya, kondisi kedua merupakan \textit{recursive case}. Sama seperti pada predikat \textit{load\_rules$/$}0, predikat \textit{load\_rule$/$}1 akan dieksekusi sebagai sebuah \textit{goal}. Setelah eksekusi predikat \textit{load\_rule$/$}1, terjadi pemanggilan rekursif terhadap predikat \textit{load\_just\_facts$/$}0 yang terus diulang hingga bertemu dengan term \textit{endProlog$/$}0.

\subsection{Predikat \textit{add\_indices/}0}
\label{subsec:add_indices}

Pada \hyperref[rule2to3]{\textcolor{blue}{bagian sebelumnya}} telah dijelaskan bahwa diperlukan dua buah predikat dinamis untuk menyimpan \textit{rule-rule} pada program input, yaitu predikat dinamis \textit{rule$/$}2 dan \textit{rule$/$}3. Predikat dinamis \textit{rule$/$}3 merupakan ekstensi dari predikat dinamis \textit{rule$/$}2 dengan penambahan satu buah argumen yang menyatakan urutan definisi mengenai \textit{rule} tersebut. Informasi mengenai urutan ini diperlukan untuk mengimplementasikan \textit{dual transformation by need}. Predikat \textit{add\_indices$/$}0 memanfaatkan \textit{rule$/$}2 yang sudah disimpan pada \textit{database} untuk membentuk \textit{rule$/$}3 yang sesuai. Berikut ini definisi dari predikat \textit{add\_indices$/$}0 pada \textsc{Tabdual}.
\\

\begin{lstlisting}[
caption=Definisi predikat \textit{add\_indices$/$}0,
style=prolog
]
add_indices :-
	retract(has_rules(H)),
	find_rules(H, R),
	add_indices_to_rule(R),
	add_indices,
	assert(has_rules(H)).
\end{lstlisting}

Terdapat lima buah \textit{goal} yang harus dieksekusi pada predikat \textit{add\_indices$/$}0. Predikat \textit{retract}(\textit{has\_rules$/$}1) menghapus informasi mengenai adanya \textit{rule H} dari \textit{database}. Dengan memanfaatkan \textit{rule$/$}2 yang sudah disimpan di \textit{database}, predikat \textit{find\_rules$/$}2 mengoleksikan seluruh \textit{rule} mengenai \textit{H} ke dalam sebuah \textit{list R}. Predikat \textit{add\_indices\_to\_rule$/$}1 menggunakan \textit{R} untuk membentuk sekaligus menyimpan \textit{rule$/$}3 yang sesuai. Selanjutnya terjadi pemanggilan rekursif terhadap predikat \textit{add\_indices$/$}0. Pemanggilan rekursif ini akan terus dilakukan hingga tidak ada lagi \textit{has\_rules$/$}1 pada \textit{database}. Setelah pemanggilan rekursif selesai dilakukan, setiap \textit{has\_rules$/$}1 yang baru saja dihapus ditambahkan kembali ke dalam \textit{database} untuk dapat dipergunakan lagi.

\label{subsec:mode}
\subsection{Predikat \textit{switch\_mode/}1}

\textsc{Tabdual} memiliki dua mode transformasi yang dapat dipilih oleh pengguna, yaitu transformasi \textit{normal} dan transformasi \textit{subsumed}. Mode transformasi \textit{normal} akan menghasilkan program output yang akan menggunakan teknik \textit{tabling} standar yang disediakan oleh XSB Prolog, sedangkan mode transformasi \textit{subsumed} akan menghasilkan program output yang akan menggunakan teknik \textit{tabling} dengan memanfaaatkan fitur \textit{answer subsumption}. Mode ransformasi \textit{normal} dapat digunakan ketika pengguna ingin melakukan \textit{abduction} untuk menememukan seluruh penjelasan terkait observasi yang diberikan. Mode transformasi \textit{subsumed} dapat digunakan ketika pengguna hanya tertarik untuk menemukan penjelasan-penjelasan minimal terkait observasi yang diberikan. \textsc{Tabdual} menyediakan predikat \textit{switch\_mode$/$}1 yang dapat digunakan untuk beralih dari satu mode transformasi ke mode lainnya. Hanya ada dua nilai yang dapat digunakan sebagai argumen dari predikat \textit{switch\_mode$/$}1, yaitu \textit{normal} atau \textit{subsumed}. Secara \textit{default}, mode transformasi yang digunakan yaitu mode transformasi \textit{normal}.

\section{Transformasi}
\label{transform}

Bagian ini menjelaskan implementasi \textsc{Tabdual} yang berkaitan dengan fase transformasi program input menjadi program output. Pada \textsc{Tabdual} fase transformasi dilakukan oleh predikat \textit{transform$/$}0 dan predikat \textit{transform\_just\_facts$/$}0. Pada \textsc{Tabdual} predikat \textit{transform$/$}0 didefinisikan sebagai berikut.
\\

\begin{lstlisting}[
caption=Definisi predikat \textit{transform$/$}0,
style=prolog
]
transform :- 
	transform_per_rule,
	transform_if_no_ic,
	transform_abducibles.
\end{lstlisting}

Terdapat tiga buah \textit{goal} yang harus dieksekusi oleh predikat \textit{transform$/$}0. Predikat \textit{transform\_per\_rule$/$}0 membentuk transformasi $\tau'$, $\tau^+$, dan $\tau^-$ untuk program input \textit{P} (transformasi $\tau^*$  dibentuk secara \textit{on-the-fly} saat fase \textit{abduction} menggunakan \textit{dual transformation by need}). Predikat \textit{transform\_if\_no\_ic$/$}0 membentuk transformasi $\tau^- = \textit{not}\_\bot(\textit{I},\textit{I})$ jika pada program input \textit{P} tidak terdapat \textit{integrity constraint}. Predikat \textit{transform\_abducibles$/$}0 membentuk transformasi $\tau^\circ$ untuk program input \textit{P}. Bagian berikutnya akan menjelaskan lebih lanjut mengenai ketiga predikat di atas serta predikat \textit{transform\_just\_facts$/$}0.

\subsection{Predikat \textit{transform\_per\_rule$/$}0}

Predikat \textit{transform\_per\_rule$/$}0 digunakan untuk membentuk transformasi $\tau'$, $\tau^+$, dan $\tau^-$. Transformasi ini dilakukan setelah seluruh program input dibaca dan sudah disimpan di dalam \textit{database} menggunakan predikat-predikat dinamis yang sesuai. Berikut ini definisi dari predikat \textit{transform\_per\_rule$/$}0 yang diberikan oleh \textsc{Tabdual}.
\\

\begin{lstlisting}[
caption=Definisi predikat \textit{transform\_per\_rule$/$}0,
style=prolog
]
transform_per_rule :-
	retract(has_rules(H)),
	find_rules(H, R),
	generate_apostrophe_rules(R),
	generate_positive_rules(H),
	generate_dual_rules(H, R),
	transform_per_rule.
\end{lstlisting}

Predikat \textit{retract$/$}1 menghapus informasi mengenai \textit{rule H} dari \textit{database}. Predikat \textit{find\_rules$/$}2 menggunakan \textit{H} untuk mengoleksikan semua rule mengenai \textit{H} yang terdapat di \textit{database}. Koleksi tersebut dikumpulkan ke dalam list \textit{R} yang kemudian digunakan oleh predikat \textit{generate\_apostrophe\_rules$/$}1, \textit{generate\_positive\_rules$/$}1, dan (disertai dengan \textit{H} juga digunakan oleh) \textit{generate\_dual\_rules$/$}2. Predikat \textit{generate\_apostrophe\_rules$/$}1 digunakan untuk membentuk transformasi $\tau'$. Predikat \textit{generate\_positive\_rules$/$}1 digunakan untuk membentuk $\tau^+$. Predikat \textit{generate\_dual\_rules$/$}1 digunakan untuk membentuk $\tau^-$ yang sudah disesuaikan agar dapat menerapkan \textit{dual transformation by need}.

\subsection{Predikat \textit{transform\_if\_no\_ic$/$}0}

Predikat \textit{transform\_if\_no\_ic$/$}0 digunakan untuk membentuk \textit{not}\_$\bot(\textit{I},\textit{I}$) sebagai hasil transformasi $\tau^-$ ketika tidak terdapat \textit{integrity constraint} pada program input. Predikat \textit{transform\_if\_no\_ic$/$}0 didefinisikan oleh \textsc{Tabdual} seperti berikut.
\\

\begin{lstlisting}[
caption=Definisi predikat \textit{transform\_if\_no\_ic$/$}0,
style=prolog
]
transform_if_no_ic :-
	find_rules(false, R),
	length(R, 0),
	generate_dual_rules_no_ic.
\end{lstlisting}

Predikat \textit{find\_rules$/$}2 mengoleksikan seluruh \textit{rule} yang merupakan \textit{integrity constraint}, yaitu \textit{rule} yang \textit{head}-nya adalah predikat \textit{false}, dan mengumpulkan hasil koleksi ke dalam \textit{list R}. Untuk mengecek terdapat atau tidaknya \textit{integrity constraint}, predikat \textit{built-in length$/$}2 digunakan untuk melakukan pengecekan apakah panjang dari \textit{R} sama dengan nol. Jika ya, maka hasil transformasi $\tau^- = \textit{not}\_\bot(\textit{I},\textit{I})$ akan dibentuk oleh predikat \textit{generate\_dual\_rules\_no\_ic$/$}0.

\subsection{Predikat \textit{transform\_abducibles$/$}0}

Predikat \textit{transform\_abducibles$/$}0 digunakan untuk membentuk transformasi $\tau^\circ$. \textsc{Tabdual} memberikan definisi untuk predikat \textit{transform\_abducibles$/$}0 seperti di bawah ini.
\\

\begin{lstlisting}[
caption=Definisi predikat \textit{transform\_abducibles$/$}0,
style=prolog
]
transform_abducibles :-
	get_abducibles(A),
	generate_abd_rules(A).
\end{lstlisting}

Predikat \textit{get\_abducibles$/$}1 mengoleksikan seluruh \textit{abducible} yang terdapat pada program input dan mengumpulkan hasil koleksinya ke dalam \textit{list A}. \textit{Abducible} yang telah dikumpulkan pada \textit{A} digunakan oleh predikat \textit{generate\_abd\_rules$/$}1 untuk membentuk transformasi $\tau^\circ$, yaitu transformasi dari masing-masing \textit{abducible} yang ada pada \textit{A}.

\subsection{Predikat \textit{transform\_just\_facts$/$}0}
\label{justfacts}

Pada \hyperref[justfacts2]{\textcolor{blue}{bagian sebelumnya}} telah dijelaskan bahwa predikat \textit{transform\_just\_facts$/$}0 melakukan transformasi terhadap term-term yang terdapat di antara predikat \textit{beginProlog$/$}0 dan \textit{endProlog$/$}0 sesuai dengan aturan transformasi pada bagian ???.  \textsc{Tabdual} melakukan transformasi terhadap term-term tersebut tepat setelah membaca predikat \textit{endProlog$/$}0 pada program input. Berikut ini definisi dari predikat \textit{transform\_just\_facts$/$}0 yang pada \textsc{Tabdual}.
\\

\begin{lstlisting}[
caption=Definisi predikat \textit{transform\_just\_facts$/$}0,
style=prolog
]
transform_just_facts :-
	retract(has_rules(F)),
	generate_pos_fact(F),
	generate_neg_fact(F),
	transform_just_facts.
\end{lstlisting}

Predikat \textit{retract$/$}1 menghapus informasi mengenai \textit{rule F} dari \textit{database}. Predikat \textit{generate\_pos\_fact$/$}1 dan \textit{generate\_neg\_fact$/$}1 menggunakan \textit{F} yang didapat untuk melakukan transformasi terhadap \textit{F}, berturut-turut untuk membentuk \textit{rule} hasil transformasi \textit{F$'$} positif dan negatif sesuai dengan aturan transformasi pada bagian ???. Selanjutnya terjadi pemanggilan rekursif terhadap predikat \textit{transform\_just\_facts$/$}0 yang terus dilakukan hingga seluruh term yang terdapat di antara \textit{beginProlog$/$}0 dan \textit{endProlog$/$}0 ditransformasikan.

\section{\textit{Abduction}}

Bagian ini menjelaskan implementasi \textsc{Tabdual} yang berkaitan dengan fase \textit{abduction}. Pada fase ini, konsep \textit{abduction} digunakan untuk memberikan jawaban terhadap suatu \textit{query} yang diberikan. Seperti yang sudah dijelaskan pada bagian ???, \textsc{Tabdual} juga melakukan transformasi terhadap \textit{query} yang diberikan sehingga \textit{contextual abduction} dapat diterapkan pada \textit{query} tersebut. Selain itu, sebelum dapat memberikan \textit{query}, program output yang dihasilkan oleh fase transformasi perlu di-\textit{consult} terlebih dahulu.

\subsection{Men-\textit{consult} Program Output}

Agar dimuat ke dalam \textit{database}, program output yang dihasilkan dari transformasi perlu untuk di-\textit{consult} terlebih dahulu. \textsc{Tabdual} mendefinisikan predikat \textit{load$/$}1 untuk men-\textit{consult} program output yang dihasilkan. Argumen dari predikat \textit{load$/$}1 yaitu nama program input yang ditransformasikan. Predikat \textit{load$/$}1 dapat menggunakan nama program input sebagai argumennya karena \textsc{Tabdual} menyimpan hasil transformasi ke program output dengan nama berkas yang sama dengan program input, hanya berbeda pada ekstensi berkasnya saja. Sebagai contoh, jika ingin men-\textit{consult} program output hasil dari transformasi program input yang nama berkasnya adalah \textit{in.ab}, maka cukup gunakan \textit{load}(\textit{in}).

\subsection{Transformasi \textit{Query}}

Pada bagian ??? telah dijelaskan bahwa agar dapat mengaplikasikan \textit{contextual abduction}, \textit{query} yang diberikan juga perlu ditransformasikan. \textsc{Tabdual} mendefinisikan predikat \textit{ask$/$}2 yang dapat digunakan untuk memberikan \textit{query}. Argumen pertama dari predikat \textit{ask$/$}2 adalah \textit{query} yang ingin dieksekusi dan argumen keduanya adalah jawaban yang diberikan \textsc{Tabdual} atas \textit{query} tersebut. Sebelum \textit{query} yang diberikan dieksekusi, predikat \textit{ask$/$}2 melakukan transformasi terhadap \textit{query} tersebut sesuai dengan aturan transformasi yang sudah dijelaskan pada bagian ???. Selain predikat \textit{ask$/$}2, \textsc{Tabdual} juga mendefinisikan predikat \textit{ask$/$}3 yang dapat digunakan untuk memberikan \textit{query} dengan \textit{input context} tertentu. Argumen pertama dari \textit{ask$/$}3 yaitu \textit{query} yang ingin dieksekusi, argumen keduanya yaitu \textit{input context} yang ingin diberikan dan direpresentasikan sebagai sebuah \textit{list}, dan argumen ketiganya yaitu jawaban yang diberikan \textsc{Tabdual} atas \textit{query} tersebut. Berikut ini merupakan definisi dari predikat \textit{ask$/$}2 dan \textit{ask$/$}3 yang didefinisikan oleh \textsc{Tabdual}.
\\

\begin{lstlisting}[
caption=Definisi predikat \textit{ask$/$}2 dan \textit{ask$/$}3,
style=prolog
]
ask(Q, O) :- 
	ask(Q, [], O).
ask(Q, I, O) :-
	transform_and_call_query(Q, I, O).
\end{lstlisting}

Terlihat bahwa predikat \textit{ask$/$}2 akan mengeksekusi predikat \textit{ask$/$}3 tanpa \textit{input context} apapun. Selanjutnya, predikat \textit{transform\_and\_call\_query$/$}3 melakukan transformasi sekaligus melakukan eksekusi terhadap \textit{query Q} yang diberikan.

 \section{Predikat Sistem dari \textsc{Tabdual}}

Bagian ini menjelaskan predikat-predikat yang didefinisikan secara khusus untuk digunakan oleh \textsc{Tabdual} dalam melakukan transformasi ataupun dalam melakukan \textit{contextual abduction}.

\subsection{Predikat \textit{produce\_context$/$}/3}

Predikat \textit{produce\_context$/$}3 digunakan untuk menggabungkan himpunan \textit{input context} dan \textit{tabled context} (\textit{context} yang didapatkan dari \textit{table}) untuk menghasilkan \textit{output context}. Argumen-argumen dari predikat \textit{produce\_context$/$}3 secara berturut-turut yaitu \textit{output context O}, \textit{input context I}, dan \textit{tabled context E}, ketiganya direpresentasikan sebagai \textit{list}. Selain menggabungkan, predikat \textit{produce\_context$/$}3 juga melakukan pengecekan apakah \textit{I} konsisten dengan \textit{E}, yaitu apakah terdapat dua literal yang saling berlawanan pada \textit{I} dan \textit{E}. Berikut ini definisi predikat \textit{produce\_context$/$}3 pada \textsc{Tabdual} yang didefinisikan secara rekursif untuk menambahkan \textit{E} satu per satu ke dalam \textit{I} dengan memperhatikan konsistensinya.
\\

\begin{lstlisting}[
caption=Definisi predikat \textit{produce\_context$/$}3,
style=prolog
]
produce_context(I, I, []).
produce_context(E, [], E).
produce_context(O, I, [E|EE]) :-
	member(E, I), !,
	produce_context(O, I, EE).
produce_context(O, I, [E|EE]) :-
	negate(E, NE),
	\+ member(NE, I),
	append(I, [E], IE),
	produce_context(O, IE, EE).
\end{lstlisting}

Terdapat empat definisi untuk predikat \textit{produce\_context$/$}3. Definisi pertama dan kedua digunakan untuk mengatasi berturut-turut jika tidak ada \textit{input context} yang diberikan dan tidak ada \textit{tabled context} yang didapatkan. Definisi ketiga digunakan untuk mengatasi kasus ketika sebuah \textit{abducible E} pada \textit{tabled context} sudah terdapat pada \textit{input context I}. Definisi keempat digunakan untuk menambahkan suatu \textit{abducible E} pada \textit{tabled context} yang tidak terdapat pada \textit{input context I}, tentu dengan memperhatikan konsistensinya. Predikat \textit{produce\_context$/$}3 akan gagal ketika ditemukan inkonsistensi antara \textit{input context} dengan \textit{tabled context}.

\subsection{Predikat \textit{insert\_abducible$/$}/3}

Predikat \textit{insert\_abducible$/$}3 digunakan untuk menambahkan sebuah \textit{abducible} pada suatu \textit{input context}. Argumen-argumen dari predikat \textit{insert\_abducible$/$}3 secara berturut-turut yaitu \textit{abducible} yang ingin ditambahkan, \textit{input context} yang ingin ditambahkan dengan \textit{abducible} pada argumen pertama, dan \textit{context} yang dihasilkan dari penambahan tersebut. Sama halnya dengan predikat \textit{produce\_context$/$}3, predikat \textit{insert\_abducbile$/$}3 juga memperhatikan konsistensi saat melakukan penambahan. Predikat \textit{insert\_abducible$/$}3 didefinisikan pada \textsc{Tabdual} seperti di bawah ini.
\\

\begin{lstlisting}[
caption=Definisi predikat \textit{insert\_abducible$/$}3,
style=prolog
]
insert_abducible(A, I, I) :-
	member(A, I), !.
insert_abducible(A, I, O) :-
	negate(A, NA),
	\+ member(NA, I),
	append(I, [A], O).
\end{lstlisting}

Terdapat dua buah definisi untuk predikat \textit{insert\_abducible$/$}3. Definisi pertama digunakan untuk mengatasi kasus ketika \textit{abducible} yang ingin ditambahkan, \textit{A}, sudah terdapat pada \textit{input context I}. Definisi kedua digunakan untuk mengatasi kasus ketika \textit{abducible} yang ingin ditambahkan, \textit{A}, belum terdapat pada \textit{input context I}. Predikat \textit{insert\_abducible$/$}3 akan gagal ketika ditemukan inkonsistensi pada \textit{output context O} setelah menambahkan \textit{abducible A} pada \textit{input context I}.

\subsection{Predikat \textit{dual}/4}

Predikat \textit{dual$/$}4 digunakan untuk melakukan \textit{dual transformation by need} yang telah dijelaskan pada bagian ???, yaitu dengan membuat transformasi $\tau^*$ secara \textit{on-the-fly} ketika memang \textit{rule} spesifik dari $\tau^*$ diperlukan saat fase \textit{abduction} dan menyimpan $\tau^*$ yang sudah ditransformasikan ke dalam \textit{trie} agar dapat dipergunakan kembali. \textit{Dual rule} yang disimpan pada \textit{trie} direpresentasikan secara \textit{generic} menggunakan predikat \textit{d}(\textit{N}, \textit{P}, \textit{Dual}, \textit{Pos}), menyimpan informasi bahwa \textit{Dual} adalah \textit{dual rule} ke-\textit{N} dari \textit{rule P} disertai dengan \textit{Pos} yang menyimpan informasi mengenai posisi \textit{goal} mana pada \textit{P} yang sedang dan belum di-\textit{dual}-kan. \textsc{Tabdual} memberikan definisi untuk predikat \textit{dual$/$}4 sebagai berikut.
\\

\begin{lstlisting}[
caption=Definisi predikat \textit{dual$/$}4,
style=prolog
]
dual(N, P, I, O) :-
	trie_property(T, alias(dual)),
	dual(T, N, P, I, O).
	
dual(T, N, P, I, O) :-
	trie_interned(d(N, P, Dual, _), T),
	call_dual(P, I, O, Dual).
dual(T, N, P, I, O) :-
	current_pos(T, N, P, Pos),
	dualize(Pos, Dual, NextPos),
	store_dual(T, N, P, Dual, NextPos),
	call_dual(P, I, O, Dual).
\end{lstlisting}

Dengan asumsi bahwa sudah dibuat \textit{trie T} dengan alias \textit{dual}, predikat \textit{dual$/$}4 menggunakan predikat bantu \textit{dual$/$}5 yang mendapatkan akses ke \textit{trie T} dari penggunaan predikat \textit{trie\_property$/$}2. Selanjutnya, terdapat dua definisi untuk predikat \textit{dual$/$}5. Definisi pertama digunakan ketika \textit{dual rule} yang ingin dieksekusi sudah ada tersimpan di dalam \textit{trie} sehingga dapat langsung digunakan tanpa harus membentuk ulang \textit{dual rule} tersebut. \textit{Dual rule} yang tersimpan di dalam \textit{trie} diambil menggunakan predikat \textit{trie\_interned$/$}2. Setelah berhasil didapatkan, maka predikat \textit{call\_dual$/$}4 melakukan instansiasi \textit{Dual} dengan argumen-argumen yang terdapat pada \textit{P} beserta \textit{input context I}, kemudian melakukan eksekusi \textit{Dual} yang sudah terinstansiasi dan memberikan jawabannya pada \textit{output context} O. Sementara itu, definisi kedua dari \textit{dual$/$}5 digunakan untuk terlebih dahulu membentuk \textit{dual rule} yang ingin dieksekusi, baru setelah itu \textit{dual rule} tersebut disimpan ke dalam \textit{trie} dan dieksekusi. Predikat \textit{current\_pos$/$}4 digunakan untuk menentukan \textit{Pos}, yaitu posisi \textit{goal} pada \textit{rule} ke-\textit{N} dari \textit{P} yang ingin di-\textit{dual}-kan, yang dapat ditentukan berdasarkan argumen keempat dari predikat \textit{d$/$}4 yang sudah tersimpan di dalam \textit{trie}. Predikat \textit{dualize$/$}3 memanfaatkan informasi yang terdapat pada \textit{Pos} untuk membentuk \textit{dual rule Dual} serta membentuk \textit{NextPos } yang memperbarui informasi pada \textit{Pos} sehingga dapat digunakan kembali untuk proses pembentukan \textit{dual rule} berikutnya. Predikat \textit{store\_dual$/$}4 menyimpan \textit{Dual} yang baru saja dibentuk beserta informasi mengenai \textit{N}, \textit{P}, dan \textit{NextPos} ke dalam \textit{trie T} agar dapat dipergunakan kembali. Dengan cara yang sama, \textit{call\_dual$/$}4 melakukan instansiasi dan eksekusi dari \textit{dual rule Dual}.

\subsection{Predikat Sistem Lainnya}

Selain \textit{produce\_context$/$}3, \textit{insert\_abducible$/$}3, dan \textit{dual$/$}4, \textsc{Tabdual} mendefiniskan beberapa predikat bantu lainnya, beberapa diantaranya yaitu:

\begin{itemize}
	\item \textit{find\_rules$/$}2 yang digunakan untuk mengoleksikan seluruh \textit{rule} mengenai suatu predikat yang tersimpan pada \textit{database}, didefinisikan sebagai berikut.
	\\
	\begin{lstlisting}[
	caption=Definisi predikat \textit{find\_rules$/$}2,
	style=prolog
	]
find_rules(H, R) :-
	findall(rule(H, B), clause(rule(H, B), true), R).
	\end{lstlisting}
	
	Predikat \textit{find\_rules$/$} menggunakan predikat \textit{built-in} \textit{findall$/$}3 yang dapat mengoleksikan sebuah predikat yang terdapat pada \textit{database}. Predikat \textit{findall$/$}3 memiliki tiga argumen yaitu \textit{Template}, \textit{Goal}, dan \textit{List}. \textit{Template} menyatakan template yang digunakan untuk menyimpan hasil koleksi, \textit{Goal} menyatakan predikat yang ingin dikoleksikan dari \textit{database}, dan \textit{List} menyatakan himpunan hasil koleksi yang didapat yang direpresentasikan sebagai sebuah \textit{list}. Predikat \textit{clause$/$}2 yang digunakan sebagai \textit{Goal} menyatakan bahwa \textit{find\_rules$/$}2 hanya mengoleksikan dari \textit{database} dinamis.
	\item \textit{negate$/$}2 yang digunakan untuk membentuk negasi dari suatu predikat, didefinisikan sebagai berikut.
	\\
	
\begin{lstlisting}[
caption=Definisi predikat \textit{negate$/$}2,
style=prolog
]
negate((not A),A).
negate(A,(not A)).
\end{lstlisting}
	
	Predikat \textit{negate$/$}2 cukup menambahkan operator \textit{not} untuk membentuk negasi dari literal positif, atau menghilangkan operator \textit{not} yang sudah ada untuk membentuk negasi dari literal negatif.
	\item \textit{get\_abducibles$/$}1 yang digunakan untuk mengoleksikan \textit{abducible} yang sudah disimpan pada predikat dinamis, didefinisikan sebagai berikut.
	\\
\begin{lstlisting}[
caption=Definisi predikat \textit{get\_abducibles$/$}1,
style=prolog
]
get_abducibles(A) :-
	abds(A).
get_abducibles([]).
\end{lstlisting}	
	
	Predikat \textit{get\_abducibles$/$}1 cukup melakukan unifikasi argumennya, \textit{A}, dengan \textit{list abducible} yang sudah tersimpan pada \textit{database}. Jika \textit{abducible} tidak ditemukan, maka \textit{get\_abducibles$/$}1 memberikan \textit{list} kosong.
	
\end{itemize}
%-----------------------------------------------------------------------------%
\section{Implementasi \f{Cluster}}
%-----------------------------------------------------------------------------%

%-----------------------------------------------------------------------------%
\subsection{Instalasi \f{Frontend}}
%-----------------------------------------------------------------------------%
Tabel model lain, ditunjukkan pada tabel \ref{tab:infohasti}. 
\begin{table}
	\centering
	\caption{Informasi \f{cluster} X}
	\newcolumntype{g}{>{\columncolor{headertbl}}c}
	\label{tab:infohasti}
	\begin{tabular}{|g|c|}
	\hline Host Name & X\\
	\hline Cluster Name & X\\
	\hline Certificate Organization & UI\\
	\hline Certificate Locality & Depok\\
	\hline Certificate State & West Java\\
	\hline Certificate Country & ID\\
	\hline Contact & X\\
	\hline URL & http://grid.ui.ac.id\\
	\hline
	\end{tabular}
\end{table}

Ada pagebreak disini.
%supaya rapih
\pagebreak

Another type of table
\begin{table}
	\centering
	\caption{Perbandingan Partisi \f{default} dan manual}
	\newcolumntype{g}{>{\columncolor{headertbl}}c}
	\label{tab:partdisk}
	\begin{tabular}{|g|c|c|}
	\rowcolor{headertbl}
	\hline & Partisi default & Partisi manual yang dilakukan\\
	\hline / & 16 GB & 30 GB\\
	\hline /var & 4 GB & 18 GB\\
	\hline swap & 1 GB & 2 GB\\
	\hline /export & 55 GB & 26 GB\\
	\hline
	\end{tabular}
\end{table}

Program menghasilkan keluaran seperti pada kode \ref{lst:raidready}. 

\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Keluaran output},label={lst:raidready}]
[root@nas-0-0 ~]# cat /proc/mdstat 
Personalities : [raid1] 
md0 : active raid1 sda4[0] sdb2[1]
      1917672312 blocks super 1.2 [2/2] [UU]
      
unused devices: <none>
[root@nas-0-0 ~]# mdadm --detail /dev/md0 
/dev/md0:
        Version : 1.2
  Creation Time : Fri May  3 15:38:52 2013
     Raid Level : raid1
     Array Size : 1917672312 (1828.83 GiB 1963.70 GB)
  Used Dev Size : 1917672312 (1828.83 GiB 1963.70 GB)
   Raid Devices : 2
  Total Devices : 2
    Persistence : Superblock is persistent

    Update Time : Tue May 28 11:27:49 2013
          State : clean 
 Active Devices : 2
Working Devices : 2
 Failed Devices : 0
  Spare Devices : 0

           Name : nas-0-0.local:0  (local to host nas-0-0.local)
           UUID : 0754726d:3dfbd4b9:42b0f587:68631556
         Events : 28

    Number   Major   Minor   RaidDevice State
       0       8        4        0      active sync   /dev/sda4
       1       8       18        1      active sync   /dev/sdb2
\end{lstlisting}
\end{minipage}

%-----------------------------------------------------------------------------%
\subsection{Konfigurasi}\label{cha:confcluster}
%-----------------------------------------------------------------------------%
Contoh verbatim dalam itemize : 
\begin{itemize}
\item \bo{Bold ini}\\
dijalankan perintah berikut : 
\begin{Verbatim}[frame=single]
# javac Ganteng.java
# java Ganteng
\end{Verbatim}
\paragraph{}
Perilaku sistem 
\begin{Verbatim}[frame=single]
# hai
# enable
# cd /export/rocks/install/
# create distro
# sh sesuatu.sh
# reboot
\end{Verbatim}
\paragraph{}

\item \bo{Menambahkan \f{package} pada \f{compute node}}\\
Langkah yang dilakukan adalah sebagai berikut : 
	\begin{enumerate}
	\item Masuk ke dalam direktori \co{/procfs/}
	\item Membuat/Mengubah berkas \co{xx.xml}. Jika tidak terdapat berkas tersebut, dapat disalin dari \co{skeleton.xml}.
	\item Menambahkan \f{package} yang ingin dipasang pada \f{compute node} diantara \f{tag} \co{<package>} seperti berikut : \co{<package>[package yang akan dipasang]</package>}.
	\item Menjalankan perintah berikut termasuk perintah untuk melakukan instalasi ulang seluruh \f{compute node}: 
	\begin{Verbatim}[frame=single]
# cd /export/somedir
# create
# run host
	\end{Verbatim}
	\end{enumerate}
	\paragraph{}
\end{itemize}
%-----------------------------------------------------------------------------%
\subsubsection{semakin ke dalam}
%-----------------------------------------------------------------------------%
\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Keluaran mentah untuk detail \f{job}}, label={lst:outqstatf},style=L]
[ardhi@xx ~]$ qstat -f 138
Job Id: 138.xx
    Job_Name = cur-1000-1np
    Job_Owner = ardhi@xx
    resources_used.cput = 27:21:35
    resources_used.mem = 86060kb
    resources_used.vmem = 170440kb
    resources_used.walltime = 27:24:50
    job_state = R
    queue = default
    server = hastinapura.grid.ui.ac.id
    Checkpoint = u
    ctime = Fri May 31 10:27:37 2013
    Error_Path = xx:/home/ardhi/xx/curcumin-1000/cur-1000-1np.e138
    exec_host = compute-0-5/0
    exec_port = 15003
    Hold_Types = n
    Join_Path = n
    Keep_Files = n
    Mail_Points = e
    Mail_Users = ardhi.putra@ui.ac.id
    mtime = Fri May 31 10:27:47 2013
    Output_Path = xx:/home/ardhi/xx/curcumin-1000/cur-1000-1np.o138
    Priority = 0
    qtime = Fri May 31 10:27:37 2013
    Rerunable = True
    Resource_List.nodes = 1:ppn=1
    session_id = 5768
    etime = Fri May 31 10:27:37 2013
    submit_args = cur-1000-1np.pbs
    start_time = Fri May 31 10:27:47 2013
    submit_host = xx
    init_work_dir = /home/ardhi/xx/curcumin-1000   
\end{lstlisting}
\end{minipage}

%-----------------------------------------------------------------------------%
\section{Pengujian} %lebih ke gimana cara ujinya
%-----------------------------------------------------------------------------%

%-----------------------------------------------------------------------------%
\subsection{Kasus Uji}
%-----------------------------------------------------------------------------%
Berwarna!
\begin{lstlisting}[caption=Potongan skrip submisi \f{job} melalui torqace,label={lst:grotorqace},style=shell]
# Go To working directory
cd $PBS_O_WORKDIR

#openMPI prerequisite
. /opt/torque/etc/openmpi-setup.sh

mpirun -np 5 -machinefile $PBS_NODEFILE mdrun -v -s \ 
	curcum400ps.tpr -o md_prod_curcum400_5np.trr -c lox_pr.gro
...
\end{lstlisting}
%-----------------------------------------------------------------------------%
\subsection{Kasus Uji}
%-----------------------------------------------------------------------------%
Contoh skrip yang dimasukkan pada \f{form} yang disediakan dapat dilihat pada kode \ref{lst:makebzip}.
\begin{lstlisting}[caption={Potongan \co{Makefile} \f{project}}, label={lst:makebzip},style=shell]
# Make file for MPI
SHELL=/bin/sh

# Compiler to use
# You may need to change CC to something like CC=mpiCC
# openmpi : mpiCC
# mpich2  : /opt/mpich2/gnu/bin/mpicxx
CC=mpiCC
...
...
\end{lstlisting}