%-----------------------------------------------------------------------------%
\chapter{\babTiga}
%-----------------------------------------------------------------------------%
Pada bab ini penulis akan menjelaskan bagaimana implementasi \textit{tabling} pada \textit{contextual abduction} dengan memanfaatkan fitur \textit{answer subsumption} yang dibuat menggunakan salah satu distribusi bahasa pemrograman Prolog, yaitu \textbf{XSB}. Pada bagian-bagian selanjutnya, program implementasi ini disebut sebagai \textsc{Tabdual}.

\section{Terminologi}

Pada bagian ini penulis menjelaskan beberapa ketentuan dan istilah yang digunakan pada bagian-bagian berikutnya, yaitu:

\begin{itemize}
	\item Pada prolog, variabel diawali dengan huruf kapital sedangkan term dan predikat diawali dengan huruf non-kapital.
	\item \textit{Consult} berarti melakukan kompilasi program Prolog dan memuat hasil kompilasi program tersebut ke dalam \textit{database} XSB sehingga program tersebut menjadi \textit{knowledge base}.
	\item \textit{Database} berarti kumpulan predikat-predikat yang disimpan pada \textit{environment} XSB dan dijadikan sebagai \textit{knowledge base} selama eksekusi. Predikat-predikat yang ada pada \textit{database} dapat berasal dari program yang di-\textit{consult} (membentuk \textit{database} statis) ataupun ditambahkan selama eksekusi suatu program (membentuk \textit{database} dinamis). Selama eksekusi, predikat yang sudah ditambahkan ke dalam \textit{database} dinamis dapat dimanipulasi sesuai kebutuhan program.
	\item \textit{Dual transformation by need} mengacu pada proses transformasi dual \textit{by need} yang sudah dijelaskan pada bagian ???.
\end{itemize}

\section{Spesifikasi \textsc{Tabdual}}

\subsection{Tahapan \textsc{Tabdual}}

Secara garis besar, \textsc{Tabdual} terbagi menjadi 2 fase:

\begin{enumerate}
	\item \textbf{Transformasi}. Pada fase ini, \textsc{Tabdual} akan melakukan transformasi program \textit{input} \textit{P} menjadi program \textit{output} \textit{P$'$} yang dapat mengaplikasikan \textit{contextual abduction}. Transformasi dilakukan sesuai dengan aturan-aturan transformasi yang sudah dijelaskan pada \hyperref[bab2]{\textcolor{blue}{bagian 2}}.
	\item \textbf{Abduction}. \textit{Contextual abduction} dapat dilakukan setelah program \textit{input} \textit{P} berhasil di-\textit{transform} menjadi program \textit{output} \textit{P$'$}. Praktis, \textit{P$'$} harus di-\textit{consult} terlebih dahulu sebelum kita dapat memberikan \textit{query} dan melakukan \textit{contextual abduction}.
\end{enumerate}

Penjelasan lebih detil mengenai setiap fase akan penulis jabarkan pada bagian-bagian berikutnya.

\subsection{Berkas Implementasi \textsc{Tabdual}}
Agar dapat digunakan secara modular, implementasi \textsc{Tabdual} dipecah ke dalam empat buah berkas yang berbeda. Keeempat berkas tersebut yaitu:

\begin{itemize}
	\item \textit{tabdual.p}. Berkas ini berisi implementasi utama dari \textsc{Tabdual}, baik implementasi untuk fase transformasi maupun implementsai untuk fase \textit{abduction}. Berkas ini adalah berkas yang harus di-\textit{consult} untuk dapat menggunakan \textsc{Tabdual}. Berkas-berkas lain yang diperlukan selama menggunakan \textsc{Tabdual} akan di-\textit{consult} melalui berkas ini.
	\item \textit{system.p}. Berkas ini berisi predikat-predikat bantuan dan predikat-predikat yang didefinisikan secara khusus yang akan digunakan  oleh \textsc{Tabdual} ketika melakukan \textit{tabling}, \textit{contextual abduction}, dan \textit{answer subsumption}. 
	\item \textit{read\_clause.p} Berkas ini berisi predikat-predikat yang dikhususkan untuk membaca program \textit{input} agar dapat diproses dan ditransformasikan menggunakan \textsc{Tabdual}.
	\item \textit{write\_clause.p}. Berkas ini berisi predikat-predikat yang dikhususkan untuk menulis transformasi dari program \textit{input} yang dihasilkan menggunakan \textsc{Tabdual} ke program \textit{output}.
\end{itemize}

\subsection{Program \textit{Input} \textsc{Tabdual}}
Program \textit{input} yang ingin di-\textit{transform} menggunakan \textsc{Tabdual} harus memenuhi kriteria-kriteria berikut:

\begin{itemize}
	\item \textit{Rule} ditulis dalam bentuk \textit{H $\leftarrow B_1, \textellipsis,B_n.$}, dengan operator $\leftarrow$ ditulis sebagai "<-" (tanda lebih kecil dari dari lalu \textit{dash}).
	\item Fakta ditulis dalam bentuk \textit{H}. saja tanpa operator $\leftarrow$.
	\item \textit{Abducible} pada program ditulis sebagai fakta menggunakan predikat \textit{abds$/$}1. Argumen dari predikat ini yaitu himpunan \textit{abducible} yang ada pada program beserta dengan \textit{arity}-nya, direpresentasikan sebagai sebuah \textit{list}.
	\item Predikat-predikat yang hanya berupa fakta dan \textit{rule-rule} yang tidak ingin di-\textit{transform} ditulis terpisah di bagian paling atas program \textit{input}, di antara predikat \textit{beginProlog} dan \textit{endProlog}. 
	\item Setiap \textit{rule} dan fakta yang ditulis diakhiri dengan tanda titik (".").
\end{itemize}

\noindent Agar lebih jelas, berikut ini merupakan contoh program yang diterima sebagai program \textit{input} untuk \textsc{Tabdual}.
\\

\begin{lstlisting}[
caption=Contoh program \textit{input} yang diterima \textsc{Tabdual},
style=prolog,
numbers=left,
xleftmargin=3em
]
beginProlog.
q(1).
q(2).
endProlog.

abds([a/1,b/1]).

r(X) <- a(X).
s(X) <- b(X).

<- q(X), r(X), s(X).
\end{lstlisting}

\noindent Dan berikut ini merupakan contoh yang tidak diterima.
\\

\begin{lstlisting}[language=Prolog,
caption=Contoh program \textit{input} yang tidak diterima \textsc{Tabdual},
style=prolog,
numbers=left,
xleftmargin=3em
].
abds(a/1,b/1).			% argumen tidak berupa list

r(X) <- a(X).
s(X) <- b(X)			% rule tidak diakhiri dengan "."

beginProlog.			% diletakkan di bawah
q(1).
q(2).
endProlog

:- q(X), r(X), s(X).	% rule tidak menggunakan <-
\end{lstlisting}

\section{Pra Transformasi}

Bagian ini menjelaskan bagian implementasi \textsc{Tabdual} yang berkaitan dengan sebelum fase transformasi.

\subsection{\textit{Directive}}

Pada Prolog, \textit{directive} merupakan anotasi dan predikat pada program yang akan dieksekusi langsung oleh \textit{compiler} ketika program tersebut di-\textit{consult}. Berbeda dengan predikat biasa pada program, \textit{directive} tidak akan disimpan sebagai \textit{knowledge base} di \textit{database}, melainkan langsung dieksekusi. Pada \textsc{Tabdual}, \textit{directive-directive} yang ada dapat dikelompokkan menjadi beberapa kelompok.

\subsubsection{\textit{Import}}

Untuk mempermudah pengguna, XSB Prolog sudah menyediakan predikat-predikat \textit{built-in} yang dapat digunakan. Predikat \textit{built-in} tersebut dikelompokkan ke dalam modul-modul yang berbeda sesuai dengan kategori penggunaannya. \textit{Directive} berikut ini akan meng-\textit{import} beberapa predikat \textit{built-in} yang diperlukan oleh \textsc{Tabdual}.
\\

\begin{lstlisting}[
caption=Deklarasi \textit{directive}: \textit{import} modul yg diperlukan,
style=prolog,
]
:- import append/3, member/2, length/2 from basics.
:- import concat_atom/2 from string.
:- import trie_create/2, trie_drop/1 from intern.
\end{lstlisting}

Predikat \textit{append$/$}3, \textit{member$/$}2, dan \textit{length$/$}2 yang sudah disediakan dalam modul \textit{basics} berturut-turut digunakan untuk menggabungkan dua buah \textit{list}, mengecek presensi suatu elemen pada sebuah \textit{list}, dan menentukan panjang sebuah \textit{list}. Predikat \textit{concat\_atom$/$}2 yang sudah disediakan dalam modul \textit{string} digunakan untuk melakukan konkatenasi atom-atom untuk membentuk suatu atom baru. Predikat \textit{trie\_create$/$}2 dan \textit{trie\_drop$/$}1 yang sudah disediakan dalam modul \textit{intern} masing-masing digunakan untuk membuat dan menghapus \textit{trie} yang digunakan oleh \textit{dual transformation by need}.

\subsubsection{Deklarasi Operator}

Pada Prolog, pengguna dapat mendefinisikan operator logika baru menggunakan predikat \textit{built-in} \textit{op$/$}3. Predikat \textit{op$/$}3 memiliki tiga buah argumen. Argumen pertama menyatakan presedensi, argumen kedua menyatakan tipe, dan argumen ketiga menyatakan nama dari operator tersebut. Presedensi dari operator dinyatakan sebagai sebuah bilangan bulat antara 1 sampai 1200 (1 adalah presedensi dari sebuah term), semakin kecil nilainya semakin kuat presedensinya. Tipe operator menentukan apakah operator tersebut merupakan operator \textit{prefix}, \textit{infix}, atau \textit{suffix}, sekaligus menyatakan sifat assosiatif yang dimilikinya, apakah assosiatif kanan, assosiatif kiri, atau tidak assosiatif. Tipe operator yang dapat digunakan untuk operator \textit{prefix} yaitu \textit{fx} dan \textit{fy}, tipe operator yang dapat digunakan untuk operator \textit{infix} yaitu \textit{yfx}, \textit{xfy}, dan \textit{xfx}, dan tipe operator yang dapat digunakan untuk operator \textit{suffix} yaitu \textit{xf} dan \textit{yf}. Simbol \textit{f} pada tipe operator merepresentasikan posisi operator sedangkan simbol \textit{x} dan \textit{y} merepresentasikan argumen-argumennya. Simbol \textit{x} menyatakan bahwa argumen tersebut harus memiliki presedensi kurang dari presedensi operator \textit{f}, sedangkan simbol \textit{y} menyatakan bahwa argumen tersebut harus memiliki presedensi kurang dari atau sama dengan presedensi operator \textit{f}. Dengan kata lain, simbol \textit{y} menyatakan bahwa operator tersebut bersifat assosiatif, sedangkan simbol \textit{x} menyatakan bahwa operator tersebut bersifat tidak assosiatif. 
\\ \\
\textsc{Tabdual} mendeklarasikan dua buah operator baru yaitu \textit{not} dan $\leftarrow$ seperti di bawah ini.
\\

\begin{lstlisting}[
caption=Deklarasi \textit{directive}: definisi operator baru,
style=prolog
]
:- op(950, fy, not).
:- op(1110, fy, '<-').
:- op(1110, xfy, '<-').
\end{lstlisting}

Operator \textit{not} digunakan untuk menyatakan negasi dari sebuah predikat sehingga tipe operatornya adalah \textit{fy}. Operator $\leftarrow$ digunakan untuk menyatakan implikasi yang dibalik untuk digunakan ketika mendefinisikan sebuah \textit{rule-rule} pada program input. Operator $\leftarrow$ memiliki dua tipe operator untuk dua penggunaan yang berbeda. Tipe operator $\leftarrow$ yang pertama yaitu \textit{fy} digunakan untuk membentuk \textit{integrity constraint}, sedangkan tipe operator $\leftarrow$ yang kedua yaitu \textit{xfy} digunakan untuk membentuk \textit{rule}.

\subsubsection{Deklarasi Predikat Dinamis}

Predikat dinamis adalah predikat yang definisi atau nilainya dapat berubah-ubah. Predikat dinamis digunakan untuk memanipulasi \textit{database} dinamis XSB selama eksekusi. \textsc{Tabdual} mendeklarasikan empat buah predikat dinamis yang digunakan selama fase transformasi dan fase \textit{abduction}. \textit{Directive} berikut ini mendeklarasikan keempat predikat dinamis yang digunakan. 
\\

\begin{lstlisting}[
caption=Deklarasi \textit{directive}: definisi operator baru,
style=prolog
]
:- dynamic has_rules/1, rule/2, rule/3, abds/1.
\end{lstlisting}

Predikat \textit{has\_rules$/$}1 digunakan untuk menyimpan informasi mengenai predikat yang memiliki \textit{rule}, dengan kata lain, predikat-predikat yang menjadi \textit{head} pada program. Argumen dari \textit{has\_rules$/$}1 yaitu \textit{R} yang menyatakan \textit{head} yang ada pada program. \textit{Head-head} ini disimpan pada \textit{database} menggunakan predikat dinamis \textit{has\_rules$/$}1 secara \textit{distinct}. Predikat \textit{rule$/$}2 dan \textit{rule$/$}3 digunakan untuk menyimpan informasi mengenai sebuah \textit{rule} yang ada pada program. Dua buah argumen pertama dari \textit{rule$/$}2 dan \textit{rule$/$}3 yaitu \textit{H} dan \textit{B}, berturut-turut menyatakan \textit{head} dan \textit{body} dari \textit{rule} tersebut. Argumen ketiga dari \textit{rule$/$}3 yaitu sebuah bilangan \textit{N} yang menyatakan bahwa \textit{$H \leftarrow B$} adalah \textit{rule} ke-\textit{N} mengenai \textit{H}.\label{rule2to3} Penjelasan mengapa diperlukan dua buah predikat dinamis untuk menyimpan \textit{rule-rule} pada program input akan dijelaskan pada \hyperref[subsec:add_indices]{\textcolor{blue}{bagian 3.4.7}}. Predikat \textit{abds$/$}1 digunakan untuk menyimpan informasi mengenai himpunan \textit{abducible} yang direpresentasikan sebagai sebuah \textit{list}. Predikat \textit{abds$/$}1 memiliki satu buah argumen yaitu \textit{list} \textit{abducible} itu sendiri.

\subsubsection{\textit{Directive} Lainnya}

Karena dibutuhkan untuk fase transformasi dan \textit{contextual abduction}, beberapa predikat berikut ini perlu dijadikan sebagai \textit{directive} agar dieksekusi langsung ketika \textsc{Tabdual} di-\textit{consult}.
\\

\begin{lstlisting}[
caption=Deklarasi \textit{directive}: lainnya,
style=prolog
]
:- consult_files, retractall(mode/1), assert(mode(normal)).
\end{lstlisting}

Predikat \textit{consult\_files$/$}0 digunakan untuk men-\textit{consult} berkas-berkas implementasi \textsc{Tabdual} lainnya, yaitu berkas \textit{system.p}, \textit{read\_clause.p}, dan \textit{write\_clause.p}. Predikat \textit{retractall}(\textit{mode$/$}1) dan \textit{assert}(\textit{mode}(\textit{normal})) digunakan untuk me-inisialisasi ulang mode yang digunakan untuk transformasi. Penjelasan mengenai mode transformasi akan dijelaskan lebih jauh pada \hyperref[subsec:mode]{\textcolor{blue}{bagian 3.4.8}}.

\subsection{Predikat \textit{wrapper} \textit{transform$/$}1}

Fase transformasi yang dilakukan \textsc{Tabdual} di-\textit{wrap} ke dalam satu buah predikat yaitu \textit{transform$/$}1. Predikat \textit{transform$/$}1 memiliki sebuah argumen yang menyatakan nama program \textit{input} yang ingin di-\textit{transform}. Berikut definisi dari predikat \textit{transform$/$}1.
\\

\begin{lstlisting}[
caption=Definisi predikat \textit{transform$/$}1,
style=prolog
]
transform(Filename) :-
	see_input_file(Filename),
	tell_output_file(Filename),
	pre_transform,
	transform,
	seen,
	told.
\end{lstlisting}

Terdapat enam buah \textit{goal} yang harus dieksekusi pada predikat \textit{transform$/$}1. Predikat \textit{see\_input\_file$/$}1 menentukan \textit{input stream} untuk fase transformasi \textsc{Tabdual} yaitu program \textit{input} yang ingin di-\textit{transform}. Predikat \textit{tell\_output\_file$/$}1 menentukan \textit{output stream} untuk fase transformasi \textsc{Tabdual}, yaitu program \textit{output} yang akan dihasilkan. Program \textit{input} harus memiliki ekstensi \textit{.ab} dan program \textit{output} yang dihasilkan akan memiliki nama yang sama namun dengan ekstensi \textit{.p}. Predikat \textit{pre\_transform$/$}0 melakukan beberapa hal yang harus dilakukan sebelum memulai transformasi (akan dijelaskan pada \hyperref[subsec:pre_transform]{\textcolor{blue}{bagian 3.4.3}}) dan predikat \textit{transform$/$}0 adalah predikat yang akan melakukan  transformasi (akan dijelaskan pada \hyperref[transform]{\textcolor{blue}{bagian 3.4}}). Predikat \textit{seen$/$}0 dan \textit{told$/$}0 berturut-turut mengembalikan input \textit{stream} dan output \textit{stream} menjadi seperti semula yaitu \textit{prompt} Prolog.

\subsection{Predikat \textit{pre\_transform/}0}
\label{subsec:pre_transform}

Terdapat beberapa hal perlu dilakukan sebelum memulai fase transformasi. Hal-hal tersebut di-\textit{wrap} ke dalam predikat \textit{pre\_transform$/$}0 yang pada \textsc{Tabdual} didefinisikan seperti di bawah ini.
\\

\begin{lstlisting}[
caption=Definisi predikat \textit{pre\_transform$/$}0,
style=prolog
]
pre_transform :-
	clear,
	load_rules,
	add_indices.
\end{lstlisting}

Terdapat tiga buah \textit{goal} yang harus dieksekusi pada predikat \textit{pre\_transform$/$}0. Predikat \textit{clear$/$}0 mengosongkan \textit{database} dengan menghapus semua predikat dinamis yang sudah tersimpan. Predikat \textit{load\_rules$/$}0 membaca program input dan menyimpan program yang didapat ke dalam \textit{database} menggunakan predikat dinamis. Predikat \textit{add\_indices$/$}0 menambahkan indeks pada setiap \textit{rule} yang disimpan menggunakan predikat dinamis \textit{rule$/$}2. Penjelasan lebih lanjut mengenai ketiga predikat ini akan dijelaskan pada bagian-bagian berikutnya.

\subsection{Predikat \textit{clear/}0}

Predikat \textit{clear$/$}0 digunakan untuk mengosongkan \textit{database} dengan menghapus semua predikat dinamis yang sudah tersimpan, sekaligus menghapus dan membuat ulang \textit{trie} yang digunakan oleh \textit{dual transformation by need}. Pada \textsc{Tabdual} predikat \textit{clear$/$}0 didefinisikan sebagai berikut.
\\

\begin{lstlisting}[
caption=Definisi predikat \textit{clear$/$}0,
style=prolog
]
clear :-
	retractall(has_rules/1),
	retractall(rule/2),
	retractall(rule/3), 
	retractall(abds/1),
	trie_drop(dual),
	trie_create(dual).
clear :-
	trie_create(dual).
\end{lstlisting}

Empat \textit{goal} pertama pada definisi predikat \textit{clear$/$}0 menghapus seluruh predikat dinamis yang sudah disimpan menggunakan predikat \textit{built-in} \textit{retractall$/$}1. Pada \textit{goal} selanjutnya, predikat \textit{trie\_drop$/$}1 menghapus dan membuat ulang \textit{trie} dengan alias \textit{dual} yang akan digunakan oleh \textit{dual transformation by need}. Jika penghapusan gagal, maka \textit{trie\_create$/$}2 pada definisi \textit{clear$/$}0 akan dieksekusi untuk membuat \textit{trie} yang baru, juga dengan alias \textit{dual}, agar dapat digunakan oleh \textit{dual transformation by need}.

\subsection{Predikat \textit{load\_rules/}0}

Predikat \textit{load\_rules$/$}0 membaca program input \textit{rule} demi \textit{rule} dan menyimpan \textit{rule} yang dibaca ke dalam \textit{database} menggunakan predikat dinamis. Berikut ini definisi dari predikat \textit{load\_rules$/$}0 pada \textsc{Tabdual} yang didefinisikan secara rekursif.
\\

\begin{lstlisting}[
caption=Definisi predikat \textit{load\_rules$/$}0,
style=prolog,
numbers=left,
xleftmargin=3em
]
load_rules :-
	read(C),
	(
	C = end_of_file 
	-> 
	true
	;
	C = beginProlog
	->
	load_just_facts
	;
	load_rule(C), 
	load_rules
	).
\end{lstlisting}

\textit{Goal} pertama yang dieksekusi pada predikat \textit{load\_rules$/$}0  yaitu predikat \textit{built-in} \textit{read$/$}1 yang digunakan untuk membaca satu term pada input \textit{stream} yang diberikan. Argumen dari predikat \textit{read$/$}1 yaitu term yang berhasil dibaca. Selanjutnya, potongan kode dari baris 3 hingga 14 merupakan \textit{statement} kondisional yang terdiri dari tiga buah kondisi yang saling \textit{mutually exclusive}, atau dengan kata lain, dapat dibaca sebagai kondisional \textit{if\textendash else if\textendash else}. Kondisi pertama merupakan \textit{base case}, yaitu jika term yang dibaca adalah term \textit{built-in end\_of\_file$/$}0, maka program output selesai dibaca dan \textit{load\_rules$/$}0 sukses. Kondisi kedua yaitu jika term yang dibaca adalah term \textit{beginProlog$/$}0, maka predikat \textit{load\_just\_facts$/$}0 akan dieksekusi sebagai sebuah \textit{goal}. Penjelasan lebih lanjut mengenai predikat \textit{load\_just\_facts$/$}0 akan dijelaskan pada bagian selanjutnya. Kondisi ketiga merupakan \textit{recursive case}, yaitu jika kedua kondisi sebelumnya tidak terpenuhi, maka predikat \textit{load\_rule$/$}1 akan dieksekusi sebagai sebuah \textit{goal}. Predikat \textit{load\_rule$/$}1 menyimpan term yang dibaca menggunakan predikat-predikat dinamis yang sesuai dengan bentuk term tersebut, apakah merupakan \textit{abducible}, rule, atau fakta. Setelah eksekusi predikat \textit{load\_rule$/$}1, terjadi pemanggilan rekursif terhadap predikat \textit{load\_rules$/$}0 yang terus diulang hingga seluruh program input selesai dibaca.

\subsection{Predikat \textit{load\_just\_facts/}0}

Predikat \textit{load\_just\_facts/}0 membaca term-term pada program input yang ditulis di antara predikat \textit{beginProlog} dan \textit{endProlog} kemudian langsung melakukan transformasi terhadap term-term tersebut. Pada \textsc{Tabdual}, predikat \textit{load\_just\_facts$/$}0 didefinisikan secara rekursif seperti berikut.
\\

\begin{lstlisting}[
caption=Definisi predikat \textit{load\_just\_facts$/$}0,
style=prolog,
numbers=left,
xleftmargin=3em
]
load_just_facts :-
	read(C),
	(
	C = endProlog
	->
	transform_just_fact,
	load_rules
	;
	load_rule(C),
	load_just_facts
	).
\end{lstlisting}

Sama seperti predikat \textit{load\_rules$/$}0, \textit{goal} pertama yang dieksekusi pada predikat \textit{load\_just\_facts$/$}0  yaitu predikat \textit{built-in} \textit{read$/$}1 yang digunakan untuk membaca satu term pada input \textit{stream} yang diberikan. Selanjutnya, potongan kode dari baris 3 hingga 14 merupakan \textit{statement} kondisional yang terdiri dari dua buah kondisi yang saling \textit{mutually exclusive}, atau dengan kata lain, dapat dibaca sebagai kondisional \textit{if\textendash else}. Kondisi pertama merupakan \textit{base case}, yaitu ketika term yang dibaca adalah term \textit{endProlog$/$}0. Artinya, seluruh term yang terdapat di antara predikat \textit{beginProlog$/$}0 dan \textit{endProlog$/$}0 sudah dibaca dan disimpan ke dalam \textit{database} sehingga dapat digunakan oleh predikat \textit{transform\_just\_facts$/$}0 \label{justfacts2} untuk ditransformasikan sesuai dengan aturan transformasi pada bagian ???. Penjelasan lebih lanjut mengenai predikat \textit{transform\_just\_facts$/$}0 akan dijelaskan pada \hyperref[justfacts]{\textcolor{blue}{bagian 3.4.4}}. Selanjutnya, kondisi kedua merupakan \textit{recursive case}. Sama seperti pada predikat \textit{load\_rules$/$}0, predikat \textit{load\_rule$/$}1 akan dieksekusi sebagai sebuah \textit{goal}. Setelah eksekusi predikat \textit{load\_rule$/$}1, terjadi pemanggilan rekursif terhadap predikat \textit{load\_just\_facts$/$}0 yang terus diulang hingga bertemu dengan term \textit{endProlog$/$}0.

\subsection{Predikat \textit{add\_indices/}0}
\label{subsec:add_indices}

Pada \hyperref[rule2to3]{\textcolor{blue}{bagian sebelumnya}} telah dijelaskan bahwa diperlukan dua buah predikat dinamis untuk menyimpan \textit{rule-rule} pada program input, yaitu predikat dinamis \textit{rule$/$}2 dan \textit{rule$/$}3. Predikat dinamis \textit{rule$/$}3 merupakan ekstensi dari predikat dinamis \textit{rule$/$}2 dengan penambahan satu buah argumen yang menyatakan urutan definisi mengenai \textit{rule} tersebut. Informasi mengenai urutan ini diperlukan untuk mengimplementasikan \textit{dual transformation by need}. Predikat \textit{add\_indices$/$}0 memanfaatkan \textit{rule$/$}2 yang sudah disimpan pada \textit{database} untuk membentuk \textit{rule$/$}3 yang sesuai. Berikut ini definisi dari predikat \textit{add\_indices$/$}0 pada \textsc{Tabdual}.
\\

\begin{lstlisting}[
caption=Definisi predikat \textit{add\_indices$/$}0,
style=prolog
]
add_indices :-
	retract(has_rules(H)),
	find_rules(H, R),
	add_indices_to_rule(R),
	add_indices,
	assert(has_rules(H)).
\end{lstlisting}

Terdapat lima buah \textit{goal} yang harus dieksekusi pada predikat \textit{add\_indices$/$}0. Predikat \textit{retract}(\textit{has\_rules$/$}1) menghapus informasi mengenai adanya \textit{rule H} dari \textit{database}. Dengan memanfaatkan \textit{rule$/$}2 yang sudah disimpan di \textit{database}, predikat \textit{find\_rules$/$}2 mengoleksikan seluruh \textit{rule} mengenai \textit{H} ke dalam sebuah \textit{list R}. Predikat \textit{add\_indices\_to\_rule$/$}1 menggunakan \textit{R} untuk membentuk sekaligus menyimpan \textit{rule$/$}3 yang sesuai. Selanjutnya terjadi pemanggilan rekursif terhadap predikat \textit{add\_indices$/$}0. Pemanggilan rekursif ini akan terus dilakukan hingga tidak ada lagi \textit{has\_rules$/$}1 pada \textit{database}. Setelah pemanggilan rekursif selesai dilakukan, setiap \textit{has\_rules$/$}1 yang baru saja dihapus ditambahkan kembali ke dalam \textit{database} untuk dapat dipergunakan lagi.

\label{subsec:mode}
\subsection{Predikat \textit{switch\_mode/}1}

\textsc{Tabdual} memiliki dua mode transformasi yang dapat dipilih oleh pengguna, yaitu transformasi \textit{normal} dan transformasi \textit{subsumed}. Mode transformasi \textit{normal} akan menghasilkan program output yang akan menggunakan teknik \textit{tabling} standar yang disediakan oleh XSB Prolog, sedangkan mode transformasi \textit{subsumed} akan menghasilkan program output yang akan menggunakan teknik \textit{tabling} dengan memanfaaatkan fitur \textit{answer subsumption}. Mode ransformasi \textit{normal} dapat digunakan ketika pengguna ingin melakukan \textit{abduction} untuk menememukan seluruh penjelasan terkait observasi yang diberikan. Mode transformasi \textit{subsumed} dapat digunakan ketika pengguna hanya tertarik untuk menemukan penjelasan-penjelasan minimal terkait observasi yang diberikan. \textsc{Tabdual} menyediakan predikat \textit{switch\_mode$/$}1 yang dapat digunakan untuk beralih dari satu mode transformasi ke mode lainnya. Hanya ada dua nilai yang dapat digunakan sebagai argumen dari predikat \textit{switch\_mode$/$}1, yaitu \textit{normal} atau \textit{subsumed}. Secara \textit{default}, mode transformasi yang digunakan yaitu mode transformasi \textit{normal}.

\section{Transformasi}
\label{transform}

Bagian ini menjelaskan implementasi \textsc{Tabdual} yang berkaitan dengan fase transformasi program input menjadi program output. Pada \textsc{Tabdual} fase transformasi dilakukan oleh predikat \textit{transform$/$}0 dan predikat \textit{transform\_just\_facts$/$}0. Pada \textsc{Tabdual} predikat \textit{transform$/$}0 didefinisikan sebagai berikut.
\\

\begin{lstlisting}[
caption=Definisi predikat \textit{transform$/$}0,
style=prolog
]
transform :- 
	transform_per_rule,
	transform_if_no_ic,
	transform_abducibles.
\end{lstlisting}

Terdapat tiga buah \textit{goal} yang harus dieksekusi oleh predikat \textit{transform$/$}0. Predikat \textit{transform\_per\_rule$/$}0 membentuk transformasi $\tau'$, $\tau^+$, dan $\tau^-$ untuk program input \textit{P} (transformasi $\tau^*$  dibentuk secara \textit{on-the-fly} saat fase \textit{abduction} menggunakan \textit{dual transformation by need}). Predikat \textit{transform\_if\_no\_ic$/$}0 membentuk transformasi $\tau^- = \textit{not}\_\bot(\textit{I},\textit{I})$ jika pada program input \textit{P} tidak terdapat \textit{integrity constraint}. Predikat \textit{transform\_abducibles$/$}0 membentuk transformasi $\tau^\circ$ untuk program input \textit{P}. Bagian berikutnya akan menjelaskan lebih lanjut mengenai ketiga predikat di atas serta predikat \textit{transform\_just\_facts$/$}0.

\subsection{Predikat \textit{transform\_per\_rule$/$}0}

Predikat \textit{transform\_per\_rule$/$}0 digunakan untuk membentuk transformasi $\tau'$, $\tau^+$, dan $\tau^-$. Transformasi ini dilakukan setelah seluruh program input dibaca dan sudah disimpan di dalam \textit{database} menggunakan predikat-predikat dinamis yang sesuai. Berikut ini definisi dari predikat \textit{transform\_per\_rule$/$}0 yang diberikan oleh \textsc{Tabdual}.
\\

\begin{lstlisting}[
caption=Definisi predikat \textit{transform\_per\_rule$/$}0,
style=prolog
]
transform_per_rule :-
	retract(has_rules(H)),
	find_rules(H, R),
	generate_apostrophe_rules(R),
	generate_positive_rules(H),
	generate_dual_rules(H, R),
	transform_per_rule.
\end{lstlisting}

Predikat \textit{retract$/$}1 menghapus informasi mengenai \textit{rule H} dari \textit{database}. Predikat \textit{find\_rules$/$}2 menggunakan \textit{H} untuk mengoleksikan semua rule mengenai \textit{H} yang terdapat di \textit{database}. Koleksi tersebut dikumpulkan ke dalam list \textit{R} yang kemudian digunakan oleh predikat \textit{generate\_apostrophe\_rules$/$}1, \textit{generate\_positive\_rules$/$}1, dan (disertai dengan \textit{H} juga digunakan oleh) \textit{generate\_dual\_rules$/$}2. Predikat \textit{generate\_apostrophe\_rules$/$}1 digunakan untuk membentuk transformasi $\tau'$. Predikat \textit{generate\_positive\_rules$/$}1 digunakan untuk membentuk $\tau^+$ dan membentuk \textit{directive} untuk mendefinisikan \textit{tabled predicate}, predikat yang akan di-\textit{table} pada fase \textit{abduction}. Predikat \textit{generate\_dual\_rules$/$}1 digunakan untuk membentuk $\tau^-$ yang sudah disesuaikan agar dapat menerapkan \textit{dual transformation by need}.

\subsection{Predikat \textit{transform\_if\_no\_ic$/$}0}

Predikat \textit{transform\_if\_no\_ic$/$}0 digunakan untuk membentuk \textit{not}\_$\bot(\textit{I},\textit{I}$) sebagai hasil transformasi $\tau^-$ ketika tidak terdapat \textit{integrity constraint} pada program input. Predikat \textit{transform\_if\_no\_ic$/$}0 didefinisikan oleh \textsc{Tabdual} seperti berikut.
\\

\begin{lstlisting}[
caption=Definisi predikat \textit{transform\_if\_no\_ic$/$}0,
style=prolog
]
transform_if_no_ic :-
	find_rules(false, R),
	length(R, 0),
	generate_dual_rules_no_ic.
\end{lstlisting}

Predikat \textit{find\_rules$/$}2 mengoleksikan seluruh \textit{rule} yang merupakan \textit{integrity constraint}, yaitu \textit{rule} yang \textit{head}-nya adalah predikat \textit{false}, dan mengumpulkan hasil koleksi ke dalam \textit{list R}. Untuk mengecek terdapat atau tidaknya \textit{integrity constraint}, predikat \textit{built-in length$/$}2 digunakan untuk melakukan pengecekan apakah panjang dari \textit{R} sama dengan nol. Jika ya, maka hasil transformasi $\tau^- = \textit{not}\_\bot(\textit{I},\textit{I})$ akan dibentuk oleh predikat \textit{generate\_dual\_rules\_no\_ic$/$}0.

\subsection{Predikat \textit{transform\_abducibles$/$}0}

Predikat \textit{transform\_abducibles$/$}0 digunakan untuk membentuk transformasi $\tau^\circ$. \textsc{Tabdual} memberikan definisi untuk predikat \textit{transform\_abducibles$/$}0 seperti di bawah ini.
\\

\begin{lstlisting}[
caption=Definisi predikat \textit{transform\_abducibles$/$}0,
style=prolog
]
transform_abducibles :-
	get_abducibles(A),
	generate_abd_rules(A).
\end{lstlisting}

Predikat \textit{get\_abducibles$/$}1 mengoleksikan seluruh \textit{abducible} yang terdapat pada program input dan mengumpulkan hasil koleksinya ke dalam \textit{list A}. \textit{Abducible} yang telah dikumpulkan pada \textit{A} digunakan oleh predikat \textit{generate\_abd\_rules$/$}1 untuk membentuk transformasi $\tau^\circ$, yaitu transformasi dari masing-masing \textit{abducible} yang ada pada \textit{A}.

\subsection{Predikat \textit{transform\_just\_facts$/$}0}
\label{justfacts}

Pada \hyperref[justfacts2]{\textcolor{blue}{bagian sebelumnya}} telah dijelaskan bahwa predikat \textit{transform\_just\_facts$/$}0 melakukan transformasi terhadap term-term yang terdapat di antara predikat \textit{beginProlog$/$}0 dan \textit{endProlog$/$}0 sesuai dengan aturan transformasi pada bagian ???.  \textsc{Tabdual} melakukan transformasi terhadap term-term tersebut tepat setelah membaca predikat \textit{endProlog$/$}0 pada program input. Berikut ini definisi dari predikat \textit{transform\_just\_facts$/$}0 yang pada \textsc{Tabdual}.
\\

\begin{lstlisting}[
caption=Definisi predikat \textit{transform\_just\_facts$/$}0,
style=prolog
]
transform_just_facts :-
	retract(has_rules(F)),
	generate_pos_fact(F),
	generate_neg_fact(F),
	transform_just_facts.
\end{lstlisting}

Predikat \textit{retract$/$}1 menghapus informasi mengenai \textit{rule F} dari \textit{database}. Predikat \textit{generate\_pos\_fact$/$}1 dan \textit{generate\_neg\_fact$/$}1 menggunakan \textit{F} yang didapat untuk melakukan transformasi terhadap \textit{F}, berturut-turut untuk membentuk \textit{rule} hasil transformasi \textit{F$'$} positif dan negatif sesuai dengan aturan transformasi pada bagian ???. Selanjutnya terjadi pemanggilan rekursif terhadap predikat \textit{transform\_just\_facts$/$}0 yang terus dilakukan hingga seluruh term yang terdapat di antara \textit{beginProlog$/$}0 dan \textit{endProlog$/$}0 ditransformasikan.

\section{\textit{Abduction}}

Bagian ini menjelaskan implementasi \textsc{Tabdual} yang berkaitan dengan fase \textit{abduction}. Pada fase ini, konsep \textit{abduction} digunakan untuk memberikan jawaban terhadap suatu \textit{query} yang diberikan. Seperti yang sudah dijelaskan pada bagian ???, \textsc{Tabdual} juga melakukan transformasi terhadap \textit{query} yang diberikan sehingga \textit{contextual abduction} dapat diterapkan pada \textit{query} tersebut. Selain itu, sebelum dapat memberikan \textit{query}, program output yang dihasilkan oleh fase transformasi perlu di-\textit{consult} terlebih dahulu.

\subsection{Men-\textit{consult} Program Output}

Agar dimuat ke dalam \textit{database}, program output yang dihasilkan dari transformasi perlu untuk di-\textit{consult} terlebih dahulu. \textsc{Tabdual} mendefinisikan predikat \textit{load$/$}1 untuk men-\textit{consult} program output yang dihasilkan. Argumen dari predikat \textit{load$/$}1 yaitu nama program input yang ditransformasikan. Predikat \textit{load$/$}1 dapat menggunakan nama program input sebagai argumennya karena \textsc{Tabdual} menyimpan hasil transformasi ke program output dengan nama berkas yang sama dengan program input, hanya berbeda pada ekstensi berkasnya saja. Sebagai contoh, jika ingin men-\textit{consult} program output hasil dari transformasi program input yang nama berkasnya adalah \textit{in.ab}, maka cukup gunakan \textit{load}(\textit{in}).

\subsection{Transformasi \textit{Query}}

Pada bagian ??? telah dijelaskan bahwa agar dapat mengaplikasikan \textit{contextual abduction}, \textit{query} yang diberikan juga perlu ditransformasikan. \textsc{Tabdual} mendefinisikan predikat \textit{ask$/$}2 yang dapat digunakan untuk memberikan \textit{query}. Argumen pertama dari predikat \textit{ask$/$}2 adalah \textit{query} yang ingin dieksekusi dan argumen keduanya adalah jawaban yang diberikan \textsc{Tabdual} atas \textit{query} tersebut. Sebelum \textit{query} yang diberikan dieksekusi, predikat \textit{ask$/$}2 melakukan transformasi terhadap \textit{query} tersebut sesuai dengan aturan transformasi yang sudah dijelaskan pada bagian ???. Selain predikat \textit{ask$/$}2, \textsc{Tabdual} juga mendefinisikan predikat \textit{ask$/$}3 yang dapat digunakan untuk memberikan \textit{query} dengan \textit{input context} tertentu. Argumen pertama dari \textit{ask$/$}3 yaitu \textit{query} yang ingin dieksekusi, argumen keduanya yaitu \textit{input context} yang ingin diberikan dan direpresentasikan sebagai sebuah \textit{list}, dan argumen ketiganya yaitu jawaban yang diberikan \textsc{Tabdual} atas \textit{query} tersebut. Berikut ini merupakan definisi dari predikat \textit{ask$/$}2 dan \textit{ask$/$}3 yang didefinisikan oleh \textsc{Tabdual}.
\\

\begin{lstlisting}[
caption=Definisi predikat \textit{ask$/$}2 dan \textit{ask$/$}3,
style=prolog
]
ask(Q, O) :- 
	ask(Q, [], O).
ask(Q, I, O) :-
	transform_and_call_query(Q, I, O).
\end{lstlisting}

Terlihat bahwa predikat \textit{ask$/$}2 akan mengeksekusi predikat \textit{ask$/$}3 tanpa \textit{input context} apapun. Selanjutnya, predikat \textit{transform\_and\_call\_query$/$}3 melakukan transformasi sekaligus melakukan eksekusi terhadap \textit{query Q} yang diberikan.

\section{\textit{Answer Subsumption}}

Bagian ini menjelaskan bagaimana \textsc{Tabdual} mengimplementasikan fitur \textit{answer subsumption} yang disediakan oleh XSB.

\subsection{\textit{Answer Subsumption} pada XSB}
Secara \textit{default}, XSB melakukan \textit{tabling} dengan cara seperti berikut: XSB menambahkan sebuah \textit{answer A} ke dalam \textit{table T} hanya jika \textit{A} bukan merupakan \textit{variant} dari suatu \textit{answer} lain yang sudah ada pada \textit{T}. Walaupun begitu, XSB memberikan pilihan untuk dapat melakukan \textit{tabling} dengan cara yang berbeda, salah satunya yaitu dengan memanfaatkan fitur \textit{answer subsumption}. Pada XSB, terdapat dua jenis penggunaan fitur \textit{answer subsumption}, yaitu \textit{partial order answer subsumption} dan \textit{lattice answer subsumption}. Pada \textit{partial order answer subsumption}, \textit{A} ditambahkan ke dalam \textit{T} hanya jika \textit{A} adalah maksimal dibandingkan dengan \textit{answer} lainnya yang sudah terdapat pada \textit{T} berdasarkan sebuah relasi terurut parsial \textit{P} yang diberikan. Selanjutnya, jika \textit{A} ditambahkan ke dalam \textit{T}, \textit{answer} lainnya yang menurut relasi \textit{P} lebih kecil akan dihapus dari \textit{T}. Sementara, jika menggunakan \textit{lattice answer subsumption}, yang akan ditambahkan ke \textit{T} mungkin saja bukan \textit{A} melainkan gabungan yang diambil dari \textit{A} dan suatu \textit{answer} lainnya \textit{A$'$} pada \textit{T} (\textit{A$'$} tetap dihapus dari \textit{T}). Meskipun terlihat sederhana, fitur \textit{answer subsumption} ini dapat memberikan efek yang besar terhadap teknik \textit{tabling} itu sendiri.

\subsection{\textit{Answer Subsumption} pada \textsc{Tabdual}}
Untuk mendapat penjelasan yang minimal saat melakukan \textit{abduction}, \textsc{Tabdual} mengimplementasikan \textit{tabling} menggunakan \textit{partial order answer subsumption} dengan relasi \textit{subset} pada himpunan sebagai relasi terurut parsial yang digunakan. Untuk menggunakan \textit{partial order answer subsumption}, \textit{directive} yang digunakan untuk mendefinisikan \textit{tabled predicate} harus diubah. Sebagai contoh, untuk \textit{tabled predicate} \textit{$t\_ab/$}3, \textit{directive} yang digunakan diubah menjadi seperti berikut ini.
\\

\begin{lstlisting}[
caption=\textit{Directive} untuk \textit{$t\_ab/$}3 menggunakan \textit{answer subsumption},
style=prolog
]
:- table t_ab(_,_,po(subset/2)).
\end{lstlisting}

Predikat \textit{po}(\textit{subset$/$}2) ditambahkan sebagai argumen pada \textit{directive} yang mendefinisikan \textit{tabled predicate}, bersesuaian dengan argumen yang menyatakan \textit{output context} dari \textit{tabled predikat} tersebut. Predikat \textit{po}(\textit{subset$/$}2) menyatakan bahwa \textit{tabled predicate} tersebut akan di-\textit{tabling} menggunakan \textit{partial order answer subsumption} dengan predikat \textit{subset$/$}2 sebagai relasi terurut parsial yang digunakan. Definisi predikat \textit{subset$/$}2 akan dijelaskan pada \hyperref[subset]{\textcolor{blue}{bagian 3.7.4}}

\section{Predikat Sistem}

Bagian ini menjelaskan predikat-predikat yang didefinisikan secara khusus untuk digunakan oleh \textsc{Tabdual} dalam melakukan transformasi ataupun dalam melakukan \textit{contextual abduction}.

\subsection{Predikat \textit{produce\_context$/$}/3}

Predikat \textit{produce\_context$/$}3 digunakan untuk menggabungkan himpunan \textit{input context} dan \textit{tabled context} (\textit{context} yang didapatkan dari \textit{table}) untuk menghasilkan \textit{output context}. Argumen-argumen dari predikat \textit{produce\_context$/$}3 secara berturut-turut yaitu \textit{output context O}, \textit{input context I}, dan \textit{tabled context E}, ketiganya direpresentasikan sebagai \textit{list}. Selain menggabungkan, predikat \textit{produce\_context$/$}3 juga melakukan pengecekan apakah \textit{I} konsisten dengan \textit{E}, yaitu apakah terdapat dua literal yang saling berlawanan pada \textit{I} dan \textit{E}. Berikut ini definisi predikat \textit{produce\_context$/$}3 pada \textsc{Tabdual} yang didefinisikan secara rekursif untuk menambahkan \textit{E} satu per satu ke dalam \textit{I} dengan memperhatikan konsistensinya.
\\

\begin{lstlisting}[
caption=Definisi predikat \textit{produce\_context$/$}3,
style=prolog
]
produce_context(I, I, []).
produce_context(E, [], E).
produce_context(O, I, [E|EE]) :-
	member(E, I), !,
	produce_context(O, I, EE).
produce_context(O, I, [E|EE]) :-
	negate(E, NE),
	\+ member(NE, I),
	append(I, [E], IE),
	produce_context(O, IE, EE).
\end{lstlisting}

Terdapat empat definisi untuk predikat \textit{produce\_context$/$}3. Definisi pertama dan kedua digunakan untuk mengatasi berturut-turut jika tidak ada \textit{input context} yang diberikan dan tidak ada \textit{tabled context} yang didapatkan. Definisi ketiga digunakan untuk mengatasi kasus ketika sebuah \textit{abducible E} pada \textit{tabled context} sudah terdapat pada \textit{input context I}. Definisi keempat digunakan untuk menambahkan suatu \textit{abducible E} pada \textit{tabled context} yang tidak terdapat pada \textit{input context I}, tentu dengan memperhatikan konsistensinya. Predikat \textit{produce\_context$/$}3 akan gagal ketika ditemukan inkonsistensi antara \textit{input context} dengan \textit{tabled context}.

\subsection{Predikat \textit{insert\_abducible$/$}/3}

Predikat \textit{insert\_abducible$/$}3 digunakan untuk menambahkan sebuah \textit{abducible} pada suatu \textit{input context}. Argumen-argumen dari predikat \textit{insert\_abducible$/$}3 secara berturut-turut yaitu \textit{abducible} yang ingin ditambahkan, \textit{input context} yang ingin ditambahkan dengan \textit{abducible} pada argumen pertama, dan \textit{context} yang dihasilkan dari penambahan tersebut. Sama halnya dengan predikat \textit{produce\_context$/$}3, predikat \textit{insert\_abducbile$/$}3 juga memperhatikan konsistensi saat melakukan penambahan. Predikat \textit{insert\_abducible$/$}3 didefinisikan pada \textsc{Tabdual} seperti di bawah ini.
\\

\begin{lstlisting}[
caption=Definisi predikat \textit{insert\_abducible$/$}3,
style=prolog
]
insert_abducible(A, I, I) :-
	member(A, I), !.
insert_abducible(A, I, O) :-
	negate(A, NA),
	\+ member(NA, I),
	append(I, [A], O).
\end{lstlisting}

Terdapat dua buah definisi untuk predikat \textit{insert\_abducible$/$}3. Definisi pertama digunakan untuk mengatasi kasus ketika \textit{abducible} yang ingin ditambahkan, \textit{A}, sudah terdapat pada \textit{input context I}. Definisi kedua digunakan untuk mengatasi kasus ketika \textit{abducible} yang ingin ditambahkan, \textit{A}, belum terdapat pada \textit{input context I}. Predikat \textit{insert\_abducible$/$}3 akan gagal ketika ditemukan inkonsistensi pada \textit{output context O} setelah menambahkan \textit{abducible A} pada \textit{input context I}.

\subsection{Predikat \textit{dual}/4}

Predikat \textit{dual$/$}4 digunakan untuk melakukan \textit{dual transformation by need} yang telah dijelaskan pada bagian ???, yaitu dengan membuat transformasi $\tau^*$ secara \textit{on-the-fly} ketika memang \textit{rule} spesifik dari $\tau^*$ diperlukan saat fase \textit{abduction} dan menyimpan $\tau^*$ yang sudah ditransformasikan ke dalam \textit{trie} agar dapat dipergunakan kembali. \textit{Dual rule} yang disimpan pada \textit{trie} direpresentasikan secara \textit{generic} menggunakan predikat \textit{d}(\textit{N}, \textit{P}, \textit{Dual}, \textit{Pos}), menyimpan informasi bahwa \textit{Dual} adalah \textit{dual rule} ke-\textit{N} dari \textit{rule P} disertai dengan \textit{Pos} yang menyimpan informasi mengenai posisi \textit{goal} mana pada \textit{P} yang sedang dan belum di-\textit{dual}-kan. \textsc{Tabdual} memberikan definisi untuk predikat \textit{dual$/$}4 sebagai berikut.
\\

\begin{lstlisting}[
caption=Definisi predikat \textit{dual$/$}4,
style=prolog
]
dual(N, P, I, O) :-
	trie_property(T, alias(dual)),
	dual(T, N, P, I, O).
	
dual(T, N, P, I, O) :-
	trie_interned(d(N, P, Dual, _), T),
	call_dual(P, I, O, Dual).
dual(T, N, P, I, O) :-
	current_pos(T, N, P, Pos),
	dualize(Pos, Dual, NextPos),
	store_dual(T, N, P, Dual, NextPos),
	call_dual(P, I, O, Dual).
\end{lstlisting}

Dengan asumsi bahwa sudah dibuat \textit{trie T} dengan alias \textit{dual}, predikat \textit{dual$/$}4 menggunakan predikat bantu \textit{dual$/$}5 yang mendapatkan akses ke \textit{trie T} dari penggunaan predikat \textit{trie\_property$/$}2. Selanjutnya, terdapat dua definisi untuk predikat \textit{dual$/$}5. Definisi pertama digunakan ketika \textit{dual rule} yang ingin dieksekusi sudah ada tersimpan di dalam \textit{trie} sehingga dapat langsung digunakan tanpa harus membentuk ulang \textit{dual rule} tersebut. \textit{Dual rule} yang tersimpan di dalam \textit{trie} diambil menggunakan predikat \textit{trie\_interned$/$}2. Setelah berhasil didapatkan, maka predikat \textit{call\_dual$/$}4 melakukan instansiasi \textit{Dual} dengan argumen-argumen yang terdapat pada \textit{P} beserta \textit{input context I}, kemudian melakukan eksekusi \textit{Dual} yang sudah terinstansiasi dan memberikan jawabannya pada \textit{output context} O. Sementara itu, definisi kedua dari \textit{dual$/$}5 digunakan untuk terlebih dahulu membentuk \textit{dual rule} yang ingin dieksekusi, baru setelah itu \textit{dual rule} tersebut disimpan ke dalam \textit{trie} dan dieksekusi. Predikat \textit{current\_pos$/$}4 digunakan untuk menentukan \textit{Pos}, yaitu posisi \textit{goal} pada \textit{rule} ke-\textit{N} dari \textit{P} yang ingin di-\textit{dual}-kan, yang dapat ditentukan berdasarkan argumen keempat dari predikat \textit{d$/$}4 yang sudah tersimpan di dalam \textit{trie}. Predikat \textit{dualize$/$}3 memanfaatkan informasi yang terdapat pada \textit{Pos} untuk membentuk \textit{dual rule Dual} serta membentuk \textit{NextPos } yang memperbarui informasi pada \textit{Pos} sehingga dapat digunakan kembali untuk proses pembentukan \textit{dual rule} berikutnya. Predikat \textit{store\_dual$/$}4 menyimpan \textit{Dual} yang baru saja dibentuk beserta informasi mengenai \textit{N}, \textit{P}, dan \textit{NextPos} ke dalam \textit{trie T} agar dapat dipergunakan kembali. Dengan cara yang sama, \textit{call\_dual$/$}4 melakukan instansiasi dan eksekusi dari \textit{dual rule Dual}.

\subsection{Predikat Sistem Lainnya}

Selain \textit{produce\_context$/$}3, \textit{insert\_abducible$/$}3, dan \textit{dual$/$}4, \textsc{Tabdual} mendefiniskan beberapa predikat bantu lainnya, beberapa diantaranya yaitu:

\begin{itemize}
	\item \textit{find\_rules$/$}2 yang digunakan untuk mengoleksikan seluruh \textit{rule} mengenai suatu predikat yang tersimpan pada \textit{database}, didefinisikan sebagai berikut.
	\\
	\begin{lstlisting}[
	caption=Definisi predikat \textit{find\_rules$/$}2,
	style=prolog
	]
find_rules(H, R) :-
	findall(rule(H, B), clause(rule(H, B), true), R).
	\end{lstlisting}
	
	Predikat \textit{find\_rules$/$} menggunakan predikat \textit{built-in} \textit{findall$/$}3 yang dapat mengoleksikan sebuah predikat yang terdapat pada \textit{database}. Predikat \textit{findall$/$}3 memiliki tiga argumen yaitu \textit{Template}, \textit{Goal}, dan \textit{List}. \textit{Template} menyatakan template yang digunakan untuk menyimpan hasil koleksi, \textit{Goal} menyatakan predikat yang ingin dikoleksikan dari \textit{database}, dan \textit{List} menyatakan himpunan hasil koleksi yang didapat yang direpresentasikan sebagai sebuah \textit{list}. Predikat \textit{clause$/$}2 yang digunakan sebagai \textit{Goal} menyatakan bahwa \textit{find\_rules$/$}2 hanya mengoleksikan dari \textit{database} dinamis.
	
	\item \textit{negate$/$}2 yang digunakan untuk membentuk negasi dari suatu predikat, didefinisikan sebagai berikut.
	\\
	
\begin{lstlisting}[
caption=Definisi predikat \textit{negate$/$}2,
style=prolog
]
negate((not A),A).
negate(A,(not A)).
\end{lstlisting}
	
	Predikat \textit{negate$/$}2 cukup menambahkan operator \textit{not} untuk membentuk negasi dari literal positif, atau menghilangkan operator \textit{not} yang sudah ada untuk membentuk negasi dari literal negatif.
	
	\item \textit{get\_abducibles$/$}1 yang digunakan untuk mengoleksikan \textit{abducible} yang sudah disimpan pada predikat dinamis, didefinisikan sebagai berikut.
	\\
\begin{lstlisting}[
caption=Definisi predikat \textit{get\_abducibles$/$}1,
style=prolog
]
get_abducibles(A) :-
	abds(A).
get_abducibles([]).
\end{lstlisting}	
	
	Predikat \textit{get\_abducibles$/$}1 cukup melakukan unifikasi argumennya, \textit{A}, dengan \textit{list abducible} yang sudah tersimpan pada \textit{database}. Jika \textit{abducible} tidak ditemukan, maka \textit{get\_abducibles$/$}1 memberikan \textit{list} kosong.
	
	\item \label{subset} \textit{subset$/$}2 yang digunakan untuk melakukan pengecekan apakah suatu \textit{list} merupakan \textit{subset} dari \textit{list} yang lain, didefinisikan sebagai berikut.
	\\
	
\begin{lstlisting}[
caption=Definisi predikat \textit{subset$/$}2,
style=prolog
]
subset([], _).
subset([L|L1], L2):-
	member(L, L2),
	subset(L1, L2).
\end{lstlisting}
	
	Predikat \textit{subset$/$}2 melakukan pengecekan apakah \textit{list} pada argumen pertama \textit{L1} merupakan \textit{subset} dari \textit{list} pada argumen kedua \textit{L2} dengan cara melakukan pengecekan apakah setiap elemen pada \textit{L1} merupakan elemen dari \textit{L2}. Predikat \textit{subset$/$}2 digunakan sebagai relasi terurut parsial pada \textit{partial order answer subsumption} yang diimplementasikan oleh \textsc{Tabdual}.
	
\end{itemize}
%-----------------------------------------------------------------------------%
%-----------------------------------------------------------------------------%
\section{Pengujian} %lebih ke gimana cara ujinya
%-----------------------------------------------------------------------------%

%-----------------------------------------------------------------------------%
\subsection{Kasus Uji}
%-----------------------------------------------------------------------------%
Berwarna!
\begin{lstlisting}[caption=Potongan skrip submisi \f{job} melalui torqace,label={lst:grotorqace},style=shell]
# Go To working directory
cd $PBS_O_WORKDIR

#openMPI prerequisite
. /opt/torque/etc/openmpi-setup.sh

mpirun -np 5 -machinefile $PBS_NODEFILE mdrun -v -s \ 
	curcum400ps.tpr -o md_prod_curcum400_5np.trr -c lox_pr.gro
...
\end{lstlisting}
%-----------------------------------------------------------------------------%
\subsection{Kasus Uji}
%-----------------------------------------------------------------------------%
Contoh skrip yang dimasukkan pada \f{form} yang disediakan dapat dilihat pada kode \ref{lst:makebzip}.
\begin{lstlisting}[caption={Potongan \co{Makefile} \f{project}}, label={lst:makebzip},style=shell]
# Make file for MPI
SHELL=/bin/sh

# Compiler to use
# You may need to change CC to something like CC=mpiCC
# openmpi : mpiCC
# mpich2  : /opt/mpich2/gnu/bin/mpicxx
CC=mpiCC
...
...
\end{lstlisting}